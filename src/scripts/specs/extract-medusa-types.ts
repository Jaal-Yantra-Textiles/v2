/**
 * Extract Types from Medusa Generated Types
 *
 * Parses .medusa/types/query-entry-points.d.ts to extract accurate type information
 * for all entities including fields, types, enums, and relations.
 *
 * This is MUCH faster and more accurate than scanning source code because:
 * 1. Types are pre-generated by Medusa's type system
 * 2. Includes all fields, enums, and relations
 * 3. Shows nullable vs required fields
 * 4. Contains link table information
 *
 * Usage:
 *   import { extractMedusaTypes } from './extract-medusa-types'
 *   const types = await extractMedusaTypes()
 *   const designType = types.get('Design')
 */

import * as fs from "fs/promises"
import * as path from "path"

// â”€â”€â”€ Interfaces â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export interface ExtractedField {
  name: string
  type: string // "string" | "number" | "boolean" | "Date" | "JSON" | custom type
  nullable: boolean
  isArray: boolean
  isRelation: boolean
  relatedType?: string
  enumValues?: string[] // For enum fields
}

export interface ExtractedEnum {
  name: string
  values: string[]
}

export interface ExtractedType {
  name: string
  fields: ExtractedField[]
  enums: ExtractedEnum[] // Enums used by this type
  relations: ExtractedRelation[]
}

export interface ExtractedRelation {
  name: string // Field name (e.g., "partners", "feedbacks")
  targetType: string // Related entity type (e.g., "Partner", "Feedback")
  cardinality: "one-to-one" | "one-to-many" | "many-to-one" | "many-to-many"
  linkTable?: string // Link table name if exists
  isNullable: boolean
}

export interface IndexServiceEntry {
  singularName: string
  pluralName: string
  typeName: string
}

export interface MedusaTypeExtraction {
  types: Map<string, ExtractedType>
  enums: Map<string, ExtractedEnum>
  moduleBindings: Map<string, string> // module name -> service type
  indexServiceEntries: IndexServiceEntry[] // Entities queryable via container.query()
}

// â”€â”€â”€ Type Mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const SCALAR_TYPE_MAP: Record<string, string> = {
  "Scalars['ID']['output']": "string",
  "Scalars['String']['output']": "string",
  "Scalars['Boolean']['output']": "boolean",
  "Scalars['Int']['output']": "number",
  "Scalars['Float']['output']": "number",
  "Scalars['DateTime']['output']": "Date",
  "Scalars['Date']['output']": "Date",
  "Scalars['Time']['output']": "string",
  "Scalars['JSON']['output']": "JSON",
}

// â”€â”€â”€ Main Extractor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function extractMedusaTypes(
  projectRoot?: string
): Promise<MedusaTypeExtraction> {
  const root = projectRoot || process.cwd()
  const typesFile = path.join(root, ".medusa/types/query-entry-points.d.ts")
  const bindingsFile = path.join(root, ".medusa/types/modules-bindings.d.ts")
  const indexServiceFile = path.join(root, ".medusa/types/index-service-entry-points.d.ts")

  // Check if types file exists
  try {
    await fs.access(typesFile)
  } catch {
    throw new Error(
      `Medusa types file not found at ${typesFile}. Run 'medusa develop' to generate types.`
    )
  }

  const content = await fs.readFile(typesFile, "utf-8")
  const types = new Map<string, ExtractedType>()
  const enums = new Map<string, ExtractedEnum>()

  // Extract all enums first
  extractEnums(content, enums)

  // Extract all types
  extractTypes(content, types, enums)

  // Extract module bindings
  let moduleBindings = new Map<string, string>()
  try {
    const bindingsContent = await fs.readFile(bindingsFile, "utf-8")
    moduleBindings = extractModuleBindings(bindingsContent)
  } catch {
    // Bindings file may not exist
  }

  // Extract Index Service entry points (queryable entities via container.query())
  let indexServiceEntries: IndexServiceEntry[] = []
  try {
    const indexContent = await fs.readFile(indexServiceFile, "utf-8")
    indexServiceEntries = extractIndexServiceEntries(indexContent)
  } catch {
    // Index service file may not exist
  }

  return { types, enums, moduleBindings, indexServiceEntries }
}

// â”€â”€â”€ Enum Extraction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function extractEnums(content: string, enums: Map<string, ExtractedEnum>): void {
  // Pattern: export type SomeEnum = 'value1' | 'value2' | 'value3';
  const enumRegex = /export type (\w+Enum)\s*=\s*([\s\S]*?);/g
  let match

  while ((match = enumRegex.exec(content)) !== null) {
    const enumName = match[1]
    const enumBody = match[2]

    // Extract values from: 'value1' | 'value2'
    const values: string[] = []
    const valueRegex = /'([^']+)'/g
    let valueMatch

    while ((valueMatch = valueRegex.exec(enumBody)) !== null) {
      values.push(valueMatch[1])
    }

    if (values.length > 0) {
      enums.set(enumName, { name: enumName, values })
    }
  }
}

// â”€â”€â”€ Type Extraction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function extractTypes(
  content: string,
  types: Map<string, ExtractedType>,
  enums: Map<string, ExtractedEnum>
): void {
  // Pattern: export type TypeName = { ... };
  // We need to match the full type body including nested braces
  const typeRegex = /export type (\w+) = \{([^}]+(?:\{[^}]*\}[^}]*)*)\};/g
  let match

  while ((match = typeRegex.exec(content)) !== null) {
    const typeName = match[1]
    const typeBody = match[2]

    // Skip utility types and scalar types
    if (
      typeName.endsWith("Enum") ||
      typeName === "Scalars" ||
      typeName.startsWith("Maybe") ||
      typeName.startsWith("Exact") ||
      typeName.startsWith("Make") ||
      typeName.startsWith("Incremental") ||
      typeName.startsWith("Input")
    ) {
      continue
    }

    const fields: ExtractedField[] = []
    const relations: ExtractedRelation[] = []
    const typeEnums: ExtractedEnum[] = []

    // Parse each field line
    const fieldLines = typeBody.split("\n")

    for (const line of fieldLines) {
      const trimmed = line.trim()
      if (!trimmed || trimmed.startsWith("__typename")) continue

      // Pattern: fieldName: Type;
      const fieldMatch = trimmed.match(/^(\w+)(\?)?:\s*(.+);?$/)
      if (!fieldMatch) continue

      const [, fieldName, optionalMarker, rawType] = fieldMatch
      const isOptional = optionalMarker === "?"

      const field = parseFieldType(fieldName, rawType, isOptional, enums, typeEnums)
      if (field) {
        fields.push(field)

        // Check if it's a relation
        if (field.isRelation && field.relatedType) {
          relations.push({
            name: fieldName,
            targetType: field.relatedType,
            cardinality: inferCardinality(fieldName, rawType, field.isArray),
            linkTable: extractLinkTable(fieldName, rawType),
            isNullable: field.nullable,
          })
        }
      }
    }

    types.set(typeName, {
      name: typeName,
      fields,
      enums: typeEnums,
      relations,
    })
  }
}

function parseFieldType(
  fieldName: string,
  rawType: string,
  isOptional: boolean,
  allEnums: Map<string, ExtractedEnum>,
  typeEnums: ExtractedEnum[]
): ExtractedField | null {
  let type = rawType.trim().replace(/;$/, "")
  let nullable = isOptional
  let isArray = false
  let isRelation = false
  let relatedType: string | undefined
  let enumValues: string[] | undefined

  // Unwrap Maybe<T>
  const maybeMatch = type.match(/^Maybe<(.+)>$/)
  if (maybeMatch) {
    nullable = true
    type = maybeMatch[1]
  }

  // Check for Array<T> or T[]
  const arrayMatch = type.match(/^Array<Maybe<(.+)>>$/) || type.match(/^Array<(.+)>$/)
  if (arrayMatch) {
    isArray = true
    type = arrayMatch[1]

    // Unwrap inner Maybe
    const innerMaybeMatch = type.match(/^Maybe<(.+)>$/)
    if (innerMaybeMatch) {
      type = innerMaybeMatch[1]
    }
  }

  // Map scalar types
  if (SCALAR_TYPE_MAP[type]) {
    return {
      name: fieldName,
      type: SCALAR_TYPE_MAP[type],
      nullable,
      isArray,
      isRelation: false,
    }
  }

  // Check for enum type
  if (allEnums.has(type)) {
    const enumDef = allEnums.get(type)!
    enumValues = enumDef.values

    // Add to type's enum list if not already there
    if (!typeEnums.find((e) => e.name === enumDef.name)) {
      typeEnums.push(enumDef)
    }

    return {
      name: fieldName,
      type: "enum",
      nullable,
      isArray,
      isRelation: false,
      enumValues,
    }
  }

  // Check for relation (custom type)
  if (/^[A-Z]/.test(type) && !type.startsWith("Scalars")) {
    isRelation = true
    relatedType = type

    return {
      name: fieldName,
      type: "relation",
      nullable,
      isArray,
      isRelation: true,
      relatedType,
    }
  }

  // Default: treat as the raw type
  return {
    name: fieldName,
    type: type,
    nullable,
    isArray,
    isRelation: false,
  }
}

function inferCardinality(
  fieldName: string,
  rawType: string,
  isArray: boolean
): ExtractedRelation["cardinality"] {
  // Link tables indicate many-to-many
  if (fieldName.endsWith("_link")) {
    return "many-to-many"
  }

  // Arrays indicate one-to-many
  if (isArray || rawType.includes("Array<")) {
    return "one-to-many"
  }

  // Singular relations - check if it's a back-reference
  if (fieldName.endsWith("_id") || !rawType.includes("Array")) {
    return "many-to-one"
  }

  return "one-to-one"
}

function extractLinkTable(fieldName: string, rawType: string): string | undefined {
  // Extract link table name from types like LinkDesignDesignPartnerPartner
  const linkMatch = rawType.match(/Link(\w+)/)
  if (linkMatch) {
    return linkMatch[1]
  }
  return undefined
}

// â”€â”€â”€ Module Bindings Extraction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function extractModuleBindings(content: string): Map<string, string> {
  const bindings = new Map<string, string>()

  // Pattern: 'module_name': ServiceType
  const bindingRegex = /'(\w+)':\s*(?:InstanceType<\(typeof \w+\)\['service'\]>|I\w+)/g
  let match

  while ((match = bindingRegex.exec(content)) !== null) {
    bindings.set(match[1], match[0])
  }

  return bindings
}

// â”€â”€â”€ Index Service Entries Extraction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Extract Index Service entry points from index-service-entry-points.d.ts
 * These are entities that can be queried via container.query()
 *
 * Format in file:
 *   interface IndexServiceEntryPoints {
 *     feedback: Feedback
 *     feedbacks: Feedback
 *     partner: Partner
 *     partners: Partner
 *   }
 */
function extractIndexServiceEntries(content: string): IndexServiceEntry[] {
  const entries: IndexServiceEntry[] = []

  // Find the IndexServiceEntryPoints interface block
  const interfaceMatch = content.match(
    /interface\s+IndexServiceEntryPoints\s*\{([\s\S]*?)\}/
  )
  if (!interfaceMatch) {
    return entries
  }

  const interfaceBody = interfaceMatch[1]

  // Group entries by type name to find singular/plural pairs
  const typeMap = new Map<string, string[]>() // typeName -> [key1, key2, ...]

  // Pattern: entryName: TypeName
  const entryRegex = /(\w+):\s*(\w+)/g
  let match

  while ((match = entryRegex.exec(interfaceBody)) !== null) {
    const entryName = match[1]
    const typeName = match[2]

    if (!typeMap.has(typeName)) {
      typeMap.set(typeName, [])
    }
    typeMap.get(typeName)!.push(entryName)
  }

  // Build IndexServiceEntry for each type
  for (const [typeName, keys] of typeMap) {
    // Find singular and plural forms
    // Singular is typically shorter or doesn't end with 's'
    // Exception: some words like 'people' are plural form of 'person'
    let singularName = keys[0]
    let pluralName = keys.length > 1 ? keys[1] : keys[0]

    // Sort by length to identify singular (usually shorter)
    const sortedKeys = [...keys].sort((a, b) => a.length - b.length)

    // Handle special cases
    if (sortedKeys.includes("person") && sortedKeys.includes("people")) {
      singularName = "person"
      pluralName = "people"
    } else if (sortedKeys.includes("variant") && sortedKeys.includes("variants")) {
      singularName = "variant"
      pluralName = "variants"
    } else {
      // Default: shortest is singular, find one ending in 's' for plural
      singularName = sortedKeys[0]
      pluralName = sortedKeys.find((k) => k.endsWith("s")) || sortedKeys[sortedKeys.length - 1]
    }

    entries.push({
      singularName,
      pluralName,
      typeName,
    })
  }

  return entries
}

// â”€â”€â”€ Helper Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Get type info for a specific entity by name
 */
export function getEntityType(
  extraction: MedusaTypeExtraction,
  entityName: string
): ExtractedType | undefined {
  // Try exact match first
  if (extraction.types.has(entityName)) {
    return extraction.types.get(entityName)
  }

  // Try PascalCase conversion
  const pascalCase = entityName
    .split(/[_-]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("")

  if (extraction.types.has(pascalCase)) {
    return extraction.types.get(pascalCase)
  }

  // Try common variations
  const variations = [
    entityName,
    entityName + "s",
    entityName.replace(/s$/, ""),
    pascalCase,
    pascalCase + "s",
    pascalCase.replace(/s$/, ""),
  ]

  for (const variant of variations) {
    for (const [typeName, typeInfo] of extraction.types) {
      if (typeName.toLowerCase() === variant.toLowerCase()) {
        return typeInfo
      }
    }
  }

  return undefined
}

/**
 * Format extracted type as LLM-friendly context
 */
export function formatTypeForLLM(type: ExtractedType): string {
  const lines: string[] = []

  lines.push(`### ${type.name}`)
  lines.push("")
  lines.push("**Fields:**")

  for (const field of type.fields) {
    if (field.isRelation) continue // Skip relations, show separately

    let typeStr = field.type
    if (field.enumValues) {
      typeStr = `enum (${field.enumValues.slice(0, 5).join(" | ")}${field.enumValues.length > 5 ? " | ..." : ""})`
    }

    const nullableStr = field.nullable ? " (optional)" : " (required)"
    const arrayStr = field.isArray ? "[]" : ""

    lines.push(`- ${field.name}: ${typeStr}${arrayStr}${nullableStr}`)
  }

  if (type.relations.length > 0) {
    lines.push("")
    lines.push("**Relations:**")

    for (const rel of type.relations) {
      if (rel.name.endsWith("_link")) continue // Skip link tables

      const cardinalityStr =
        rel.cardinality === "one-to-many"
          ? "has many"
          : rel.cardinality === "many-to-one"
            ? "belongs to"
            : rel.cardinality === "many-to-many"
              ? "has and belongs to many"
              : "has one"

      lines.push(`- ${rel.name}: ${cardinalityStr} ${rel.targetType}`)
    }
  }

  return lines.join("\n")
}

/**
 * Format extracted type for spec JSON
 */
export function formatTypeForSpec(type: ExtractedType): {
  fields: object[]
  relations: object[]
  enums: object[]
} {
  const fields = type.fields
    .filter((f) => !f.isRelation)
    .map((f) => ({
      name: f.name,
      type: f.type,
      nullable: f.nullable,
      isArray: f.isArray,
      enumValues: f.enumValues,
    }))

  const relations = type.relations
    .filter((r) => !r.name.endsWith("_link"))
    .map((r) => ({
      name: r.name,
      targetType: r.targetType,
      cardinality: r.cardinality,
      nullable: r.isNullable,
    }))

  const enums = type.enums.map((e) => ({
    name: e.name,
    values: e.values,
  }))

  return { fields, relations, enums }
}

// â”€â”€â”€ CLI Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if (require.main === module) {
  const entityName = process.argv[2]

  extractMedusaTypes()
    .then((extraction) => {
      console.log(`\nðŸ“Š Medusa Type Extraction Results\n`)
      console.log(`Total types: ${extraction.types.size}`)
      console.log(`Total enums: ${extraction.enums.size}`)
      console.log(`Module bindings: ${extraction.moduleBindings.size}`)
      console.log(`Index Service entries: ${extraction.indexServiceEntries.length}`)

      if (entityName) {
        console.log(`\nðŸ” Looking for entity: ${entityName}\n`)

        const entityType = getEntityType(extraction, entityName)
        if (entityType) {
          console.log(formatTypeForLLM(entityType))
          console.log("\nðŸ“¦ JSON Format:")
          console.log(JSON.stringify(formatTypeForSpec(entityType), null, 2))
        } else {
          console.log(`âŒ Entity "${entityName}" not found`)
          console.log("\nAvailable types:")
          const typeNames = Array.from(extraction.types.keys())
            .filter((n) => !n.startsWith("Link"))
            .sort()
          console.log(typeNames.join(", "))
        }
      } else {
        console.log("\nUsage: npx tsx src/scripts/extract-medusa-types.ts [entity-name]")

        // Show Index Service queryable entities
        if (extraction.indexServiceEntries.length > 0) {
          console.log("\nðŸ”Ž Index Service Queryable Entities (via container.query()):")
          for (const entry of extraction.indexServiceEntries) {
            console.log(`  â€¢ ${entry.singularName} / ${entry.pluralName} â†’ ${entry.typeName}`)
          }
        }

        console.log("\nAvailable entities:")
        const typeNames = Array.from(extraction.types.keys())
          .filter((n) => !n.startsWith("Link"))
          .slice(0, 30)
          .sort()
        console.log(typeNames.join(", "))
        if (extraction.types.size > 30) {
          console.log(`... and ${extraction.types.size - 30} more`)
        }
      }
    })
    .catch(console.error)
}
