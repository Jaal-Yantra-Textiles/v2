#!/usr/bin/env node

/**
 * Enhanced RAG Module Spec Generator
 * 
 * Comprehensive module specification generator that:
 * 1. Extracts models, API routes, workflows, links, subscribers
 * 2. Uses Medusa MCP for core entity documentation
 * 3. Generates LLM-powered business process intelligence
 * 4. Creates comprehensive documentation for AI Chat V3
 */

import { createOpenRouter } from "@openrouter/ai-sdk-provider"
import { generateText } from "ai"
import * as fs from "fs/promises"
import * as path from "path"
import glob from "glob"
import { extractAPIExamples, formatExamplesForSpec, type CategorizedAPIExamples } from "./extract-api-examples"
import { extractMedusaTypes, getEntityType, formatTypeForSpec, type MedusaTypeExtraction } from "./extract-medusa-types"

interface ExtendedModuleData {
  entityName: string
  tableName: string
  description: string
  fields: FieldData[]
  relations: RelationData[]
  workflows: WorkflowData[]
  apiRoutes: APIRouteData[]
  links: LinkData[]
  subscribers: SubscriberData[]
  services: ServiceData[]
}

interface FieldData {
  name: string
  type: string
  nullable: boolean
  primaryKey: boolean
  searchable: boolean
  filterable: boolean
  enumValues?: string[]
  defaultValue?: string
}

interface RelationData {
  name: string
  targetEntity: string
  cardinality: string
  inverseSide?: string
}

interface WorkflowData {
  name: string
  description: string
  file: string
  inputType?: string
  outputType?: string
  steps: WorkflowStepData[]
  workflowCategory?: string
}

interface WorkflowStepData {
  id: string
  description?: string
}

interface APIRouteData {
  path: string
  method: string
  description: string
  requiresAuth: boolean
  pathParams: string[]
  queryParams?: string[]
  bodyType?: string
  responseType?: string
  routeCategory?: string
}

interface LinkData {
  sourceModule: string
  sourceEntity: string
  targetModule: string
  targetEntity: string
  definitionFile: string
  linkType: "one-to-one" | "one-to-many" | "many-to-many"
  isListSource?: boolean
  isListTarget?: boolean
  filterableFields?: {
    source: string[]
    target: string[]
  }
  extraColumns?: Record<string, { type: string; nullable: boolean }>
  graphQueryExample?: string
}

interface LinkBusinessIntelligence {
  linkDescription: string
  queryCapabilities: string[]
  businessContexts: string[]
  searchExamples: string[]
  dataFlowPatterns: string[]
}

/**
 * Cross-entity query pattern - shows HOW to query across entities
 */
interface CrossEntityQueryPattern {
  description: string           // "Find designs with active production runs"
  primaryEntity: string         // "production_runs" - entity to query first
  filterField?: string          // "status"
  filterValue?: string          // "in_progress"
  expandRelation: string        // "design" - relation to expand
  queryCode: string             // Actual code example
  naturalLanguageExamples: string[]  // ["designs with active production runs", "active production run designs"]
}

/**
 * Semantic status mapping - maps user terms to actual enum values
 */
interface SemanticStatusMapping {
  fieldName: string
  userTerms: Record<string, string[]>  // e.g., { "in_progress": ["active", "running", "ongoing"] }
}

/**
 * Inferred relation from foreign key field
 */
interface InferredRelation {
  fieldName: string          // "design_id"
  targetEntity: string       // "Design"
  targetModule: string       // "designs"
  cardinality: string        // "many-to-one"
  queryPattern: string       // "Filter production_runs by design_id, or expand design relation"
}

interface SubscriberData {
  event: string
  handler: string
  file: string
  description?: string
}

interface ServiceData {
  name: string
  file: string
  methods: string[]
  extendsMedusaService: boolean
}

interface BusinessProcess {
  name: string
  description: string
  steps: ProcessStep[]
  relatedModules: string[]
  kpis: string[]
}

interface ProcessStep {
  name: string
  description: string
  inputRequired: boolean
  outputGenerated: boolean
  estimatedTime?: string
}

interface CompleteModuleSpec {
  module: string
  generatedAt: string
  dataModel: {
    entityName: string
    tableName: string
    description: string
    fields: FieldData[]
    relations: RelationData[]
    inferredRelations?: InferredRelation[]  // Relations inferred from *_id fields
  }
  apiSurface: {
    routes: APIRouteData[]
    totalEndpoints: number
  }
  workflows: {
    definitions: WorkflowData[]
    count: number
  }
  integrationPoints: {
    links: LinkData[]
    subscribers: SubscriberData[]
    externalDependencies: string[]
    linkIntelligence?: LinkBusinessIntelligence[]
  }
  services: {
    definitions: ServiceData[]
    autoGeneratedMethods: string[]
  }
  businessIntelligence: {
    businessProcesses: BusinessProcess[]
    relatedCoreEntities: string[]
    dataFlowPatterns: string[]
  }
  // NEW: Query intelligence for RAG
  queryIntelligence?: {
    crossEntityPatterns: CrossEntityQueryPattern[]
    semanticMappings: SemanticStatusMapping[]
  }
  // NEW: Real API examples from integration tests
  apiExamples?: {
    create: object[]
    read: object[]
    update: object[]
    delete: object[]
    link: object[]
    action: object[]
  }
  documentation: {
    usageExamples: string[]
    commonQueries: string[]
  }
}

class EnhancedModuleSpecGenerator {
  private projectRoot: string
  private modulesDir: string
  private apiDir: string
  private linksDir: string
  private workflowsDir: string
  private subscribersDir: string
  private openrouter: any
  private mcpBaseUrl: string
  private medusaTypes: MedusaTypeExtraction | null = null

  constructor() {
    this.projectRoot = path.join(__dirname, "..", "..")
    this.modulesDir = path.join(this.projectRoot, "src/modules")
    this.apiDir = path.join(this.projectRoot, "src/api/admin")
    this.linksDir = path.join(this.projectRoot, "src/links")
    this.workflowsDir = path.join(this.projectRoot, "src/workflows")
    this.subscribersDir = path.join(this.projectRoot, "src/subscribers")
    this.mcpBaseUrl = process.env.MEDUSA_MCP_URL || "https://docs.medusajs.com/mcp"

    const apiKey = process.env.OPENROUTER_API_KEY
    if (!apiKey) {
      console.warn("‚ö†Ô∏è  OPENROUTER_API_KEY not set - using mock mode")
      this.openrouter = null
    } else {
      this.openrouter = createOpenRouter({ apiKey })
    }
  }

  /**
   * Load Medusa generated types (cached)
   */
  private async loadMedusaTypes(): Promise<MedusaTypeExtraction | null> {
    if (this.medusaTypes) return this.medusaTypes

    try {
      this.medusaTypes = await extractMedusaTypes(this.projectRoot)
      console.log(`  üì¶ Loaded ${this.medusaTypes.types.size} types from .medusa/types/`)
      return this.medusaTypes
    } catch (error) {
      console.warn(`  ‚ö†Ô∏è  Could not load Medusa types: ${error}`)
      return null
    }
  }

  /**
   * Generate complete module specification
   */
  async generateCompleteSpec(moduleName: string): Promise<CompleteModuleSpec> {
    console.log(`\nüîç Analyzing module: ${moduleName}`)
    console.log("=" .repeat(60))

    // Extract all module data
    console.log("\nüìã Step 1: Extracting data model...")
    const { fields, relations, entityName, tableName } = await this.extractDataModel(moduleName)

    console.log("\nüåê Step 2: Extracting API routes...")
    const apiRoutes = await this.extractAPIRoutes(moduleName)

    console.log("\n‚öôÔ∏è Step 3: Extracting workflows...")
    const workflows = await this.extractWorkflows(moduleName)

    console.log("\nüîó Step 4: Extracting module links...")
    const links = await this.extractLinks(moduleName)

    console.log("\nüì° Step 5: Extracting subscribers...")
    const subscribers = await this.extractSubscribers(moduleName)

    console.log("\nüîß Step 6: Extracting services...")
    const services = await this.extractServices(moduleName)

    console.log("\nüìù Step 7: Generating documentation...")
    const description = await this.generateModuleDescription(moduleName, fields, relations)

    console.log("\nü§ñ Step 8: Generating business intelligence...")
    const businessProcesses = await this.generateBusinessProcesses(
      moduleName, fields, relations, apiRoutes, workflows
    )

    console.log("\nüéØ Step 9: Finding related core entities via MCP...")
    const relatedCoreEntities = await this.findRelatedCoreEntities(moduleName, relations)

    console.log("\nüìä Step 10: Generating link intelligence...")
    const linkIntelligence = this.generateLinkIntelligence(links)

    console.log("\nüîó Step 11: Inferring relations from foreign keys...")
    const inferredRelations = this.inferRelationsFromForeignKeys(fields, moduleName)

    console.log("\nüéØ Step 12: Generating query intelligence...")
    const queryIntelligence = this.generateQueryIntelligence(
      moduleName, entityName, fields, relations, inferredRelations, links
    )

    console.log("\nüìö Step 13: Extracting API examples from integration tests...")
    let apiExamples: CategorizedAPIExamples | undefined
    try {
      apiExamples = await extractAPIExamples(moduleName, path.join(this.projectRoot, "integration-tests/http"))
      const totalExamples =
        apiExamples.create.length +
        apiExamples.read.length +
        apiExamples.update.length +
        apiExamples.delete.length +
        apiExamples.link.length +
        apiExamples.action.length
      console.log(`  ‚úÖ Extracted: ${totalExamples} API examples (create: ${apiExamples.create.length}, read: ${apiExamples.read.length}, update: ${apiExamples.update.length}, delete: ${apiExamples.delete.length}, link: ${apiExamples.link.length}, action: ${apiExamples.action.length})`)
    } catch (error) {
      console.warn(`  ‚ö†Ô∏è Could not extract API examples: ${error}`)
    }

    // Build complete spec
    const spec: CompleteModuleSpec = {
      module: moduleName,
      generatedAt: new Date().toISOString(),
      dataModel: {
        entityName,
        tableName,
        description,
        fields,
        relations,
        inferredRelations: inferredRelations.length > 0 ? inferredRelations : undefined
      },
      apiSurface: {
        routes: apiRoutes,
        totalEndpoints: apiRoutes.length
      },
      workflows: {
        definitions: workflows,
        count: workflows.length
      },
      integrationPoints: {
        links,
        subscribers,
        externalDependencies: this.findExternalDependencies(relations, links),
        linkIntelligence
      },
      services: {
        definitions: services,
        autoGeneratedMethods: this.getAutoGeneratedMethods(entityName)
      },
      businessIntelligence: {
        businessProcesses,
        relatedCoreEntities,
        dataFlowPatterns: this.identifyDataFlowPatterns(workflows, links, apiRoutes)
      },
      queryIntelligence: queryIntelligence.crossEntityPatterns.length > 0 || queryIntelligence.semanticMappings.length > 0
        ? queryIntelligence
        : undefined,
      apiExamples: apiExamples ? formatExamplesForSpec(apiExamples) as CompleteModuleSpec["apiExamples"] : undefined,
      documentation: {
        usageExamples: this.generateUsageExamples(moduleName, entityName, apiRoutes),
        commonQueries: this.generateCommonQueries(moduleName, fields, relations)
      }
    }

    return spec
  }

  /**
   * Infer relations from foreign key fields (e.g., design_id -> Design)
   */
  private inferRelationsFromForeignKeys(fields: FieldData[], moduleName: string): InferredRelation[] {
    const inferredRelations: InferredRelation[] = []

    // Known module mappings for common foreign keys
    const moduleMap: Record<string, { entity: string; module: string }> = {
      "design_id": { entity: "Design", module: "designs" },
      "partner_id": { entity: "Partner", module: "partner" },
      "product_id": { entity: "Product", module: "product" },
      "variant_id": { entity: "ProductVariant", module: "product" },
      "order_id": { entity: "Order", module: "order" },
      "customer_id": { entity: "Customer", module: "customer" },
      "region_id": { entity: "Region", module: "region" },
      "store_id": { entity: "Store", module: "store" },
      "cart_id": { entity: "Cart", module: "cart" },
      "inventory_id": { entity: "Inventory", module: "inventory" },
    }

    for (const field of fields) {
      if (field.name.endsWith("_id") && field.name !== "id") {
        const mapping = moduleMap[field.name]

        if (mapping) {
          inferredRelations.push({
            fieldName: field.name,
            targetEntity: mapping.entity,
            targetModule: mapping.module,
            cardinality: "many-to-one",
            queryPattern: `To find ${mapping.entity}s with ${moduleName}: Query ${moduleName} and expand ${field.name.replace("_id", "")} relation, OR query ${mapping.module} and filter by ${moduleName}`
          })
        } else {
          // Generic inference: design_id -> Design
          const entityName = this.toPascalCase(field.name.replace("_id", ""))
          const moduleName2 = field.name.replace("_id", "").replace(/_/g, "-")

          inferredRelations.push({
            fieldName: field.name,
            targetEntity: entityName,
            targetModule: moduleName2,
            cardinality: "many-to-one",
            queryPattern: `Filter by ${field.name} or expand the ${field.name.replace("_id", "")} relation`
          })
        }
      }
    }

    console.log(`  ‚úÖ Inferred ${inferredRelations.length} relations from foreign keys`)
    return inferredRelations
  }

  /**
   * Generate query intelligence for RAG systems
   * This is the KEY piece that tells the LLM HOW to query
   */
  private generateQueryIntelligence(
    moduleName: string,
    entityName: string,
    fields: FieldData[],
    relations: RelationData[],
    inferredRelations: InferredRelation[],
    links: LinkData[]
  ): { crossEntityPatterns: CrossEntityQueryPattern[]; semanticMappings: SemanticStatusMapping[] } {
    const crossEntityPatterns: CrossEntityQueryPattern[] = []
    const semanticMappings: SemanticStatusMapping[] = []

    // 1. Generate semantic mappings for enum fields
    for (const field of fields) {
      if (field.enumValues && field.enumValues.length > 0) {
        const userTerms: Record<string, string[]> = {}

        for (const enumValue of field.enumValues) {
          // Map common user terms to actual enum values
          const terms: string[] = []

          if (enumValue === "in_progress") {
            terms.push("active", "running", "ongoing", "in progress", "current")
          } else if (enumValue === "completed") {
            terms.push("done", "finished", "complete")
          } else if (enumValue === "cancelled") {
            terms.push("canceled", "stopped", "terminated")
          } else if (enumValue === "pending_review") {
            terms.push("pending", "awaiting review", "needs review", "under review")
          } else if (enumValue === "approved") {
            terms.push("accepted", "confirmed")
          } else if (enumValue === "draft") {
            terms.push("new", "initial", "started")
          } else if (enumValue === "sent_to_partner") {
            terms.push("sent", "dispatched", "with partner")
          }

          if (terms.length > 0) {
            userTerms[enumValue] = terms
          }
        }

        if (Object.keys(userTerms).length > 0) {
          semanticMappings.push({
            fieldName: field.name,
            userTerms
          })
        }
      }
    }

    // 2. Generate cross-entity query patterns from inferred relations
    for (const inferred of inferredRelations) {
      const relationName = inferred.fieldName.replace("_id", "")

      // Pattern: "Find X with Y" -> Query X, expand Y
      crossEntityPatterns.push({
        description: `Find ${entityName}s for a specific ${inferred.targetEntity}`,
        primaryEntity: moduleName.replace(/-/g, "_"),
        filterField: inferred.fieldName,
        filterValue: "<target_id>",
        expandRelation: relationName,
        queryCode: `// Find ${entityName}s for a ${inferred.targetEntity}
const result = await query.graph({
  entity: "${entityName}",
  fields: ["*", "${relationName}.*"],
  filters: { ${inferred.fieldName}: "<target_id>" }
})`,
        naturalLanguageExamples: [
          `${entityName}s for ${inferred.targetEntity}`,
          `${inferred.targetEntity}'s ${entityName}s`,
          `${entityName}s linked to ${inferred.targetEntity}`,
        ]
      })

      // Reverse pattern: "Find Y with active X" -> Query X with filter, expand Y
      // CRITICAL: This pattern tells the LLM to query this module (X) first when
      // filtering by status, then expand the foreign key relation to get Y
      const statusField = fields.find(f => f.name === "status" && f.enumValues)
      if (statusField) {
        const targetLower = inferred.targetEntity.toLowerCase()
        const entityLower = entityName.toLowerCase()

        crossEntityPatterns.push({
          description: `Find ${inferred.targetEntity}s with active ${entityName}s`,
          primaryEntity: moduleName.replace(/-/g, "_"),
          filterField: "status",
          filterValue: "in_progress",
          expandRelation: relationName,
          queryCode: `// Find ${inferred.targetEntity}s with active ${entityName}s
// IMPORTANT: Query ${entityName} first (where status filter exists), then expand ${relationName}
const result = await query.graph({
  entity: "${entityName}",
  fields: ["*", "${relationName}.*"],
  filters: { status: "in_progress" }  // Filter on ${entityName}, not ${inferred.targetEntity}
})
// Result contains ${entityName}s with their linked ${inferred.targetEntity}s`,
          naturalLanguageExamples: [
            // Primary patterns - what users will ask
            `find ${targetLower}s with active ${entityLower}s`,
            `${targetLower}s with active ${entityLower}s`,
            `get ${targetLower}s that have active ${entityLower}s`,
            `show ${targetLower}s with ${entityLower}s in progress`,
            // Alternative phrasings
            `active ${entityLower} ${targetLower}s`,
            `${targetLower}s that have ${entityLower}s in progress`,
            `${targetLower}s with running ${entityLower}s`,
            `${targetLower}s with ongoing ${entityLower}s`,
            // Query patterns
            `which ${targetLower}s have active ${entityLower}s`,
            `list ${targetLower}s by ${entityLower} status`,
          ]
        })
      }
    }

    // 3. Generate patterns from explicit links (defineLink relationships)
    for (const link of links) {
      const sourceLower = link.sourceEntity.toLowerCase()
      const targetLower = link.targetEntity.toLowerCase()
      const targetProp = link.targetEntity.charAt(0).toLowerCase() + link.targetEntity.slice(1)

      // Forward pattern: source -> target (e.g., "partners with feedback")
      crossEntityPatterns.push({
        description: `Query ${link.sourceEntity} with linked ${link.targetEntity}`,
        primaryEntity: link.sourceEntity,
        expandRelation: targetProp,
        queryCode: `// Query ${link.sourceEntity} with ${link.targetEntity}
const result = await query.graph({
  entity: "${link.sourceEntity}",
  fields: ["*", "${targetProp}.*"]
})`,
        naturalLanguageExamples: [
          // Forward: source with target
          `${sourceLower}s with ${targetLower}`,
          `${sourceLower}s with ${targetLower}s`,
          `get ${sourceLower}s with their ${targetLower}`,
          `find ${sourceLower}s that have ${targetLower}`,
          // Reverse: target for source (e.g., "feedback for partners")
          `${targetLower} for ${sourceLower}s`,
          `${targetLower}s for ${sourceLower}`,
          `find ${targetLower} for ${sourceLower}s`,
          `get ${targetLower} for ${sourceLower}`,
          `show ${targetLower} for ${sourceLower}s`,
          // General patterns
          `${sourceLower} ${targetLower} data`,
          `${sourceLower} ${targetLower} relationship`,
        ]
      })
    }

    console.log(`  ‚úÖ Generated ${crossEntityPatterns.length} query patterns, ${semanticMappings.length} semantic mappings`)
    return { crossEntityPatterns, semanticMappings }
  }

  /**
   * Extract data model (models, fields, relations)
   *
   * PRIORITY ORDER:
   * 1. Try .medusa/types/query-entry-points.d.ts (fastest, most accurate)
   * 2. Fall back to manual source code scanning
   */
  private async extractDataModel(moduleName: string): Promise<{
    fields: FieldData[]
    relations: RelationData[]
    entityName: string
    tableName: string
  }> {
    // Try Medusa generated types first (much faster and more accurate)
    const medusaResult = await this.extractFromMedusaTypes(moduleName)
    if (medusaResult) {
      console.log(`  ‚úÖ Extracted from .medusa/types: ${medusaResult.fields.length} fields, ${medusaResult.relations.length} relations`)
      return medusaResult
    }

    // Fall back to manual extraction
    console.log(`  ‚ö†Ô∏è  Falling back to manual source extraction...`)
    return this.extractDataModelFromSource(moduleName)
  }

  /**
   * Extract data model from .medusa/types/query-entry-points.d.ts
   */
  private async extractFromMedusaTypes(moduleName: string): Promise<{
    fields: FieldData[]
    relations: RelationData[]
    entityName: string
    tableName: string
  } | null> {
    const medusaTypes = await this.loadMedusaTypes()
    if (!medusaTypes) return null

    // Try various entity name patterns
    const entityVariants = this.generateEntityNameVariants(moduleName)

    let entityType: ReturnType<typeof getEntityType> = undefined
    let matchedEntityName = ""

    for (const variant of entityVariants) {
      const found = getEntityType(medusaTypes, variant)
      if (found) {
        entityType = found
        matchedEntityName = found.name
        break
      }
    }

    if (!entityType) {
      console.log(`  ‚ö†Ô∏è  Entity not found in Medusa types for: ${moduleName}`)
      return null
    }

    // Convert extracted types to our format
    const { fields: extractedFields, relations: extractedRelations } = formatTypeForSpec(entityType)

    const fields: FieldData[] = extractedFields.map((f: any) => ({
      name: f.name,
      type: f.enumValues ? "enum" : f.type,
      nullable: f.nullable,
      primaryKey: f.name === "id",
      searchable: ["name", "title", "handle", "description"].includes(f.name),
      filterable: !["JSON", "json"].includes(f.type),
      enumValues: f.enumValues,
    }))

    const relations: RelationData[] = extractedRelations.map((r: any) => ({
      name: r.name,
      targetEntity: r.targetType,
      cardinality: r.cardinality,
    }))

    // Derive table name from entity name (e.g., "Partner" -> "partner", "InventoryOrders" -> "inventory_orders")
    const tableName = this.toSnakeCase(matchedEntityName)

    return {
      fields,
      relations,
      entityName: matchedEntityName,
      tableName,
    }
  }

  /**
   * Generate various entity name patterns to search for
   */
  private generateEntityNameVariants(moduleName: string): string[] {
    const normalized = moduleName.toLowerCase()
    const pascalCase = this.toPascalCase(normalized)
    const singular = normalized.replace(/s$/, "")
    const singularPascal = this.toPascalCase(singular)

    return [
      pascalCase,                           // Partner
      singularPascal,                       // Partner (if module is "partners")
      pascalCase + "s",                     // Partners
      normalized,                           // partner
      singular,                             // partner (if module is "partners")
      moduleName,                           // original
      this.toPascalCase(moduleName),        // Original pascal
      // Handle special cases like inventory_orders -> InventoryOrders
      this.toPascalCase(moduleName.replace(/_/g, " ")),
      this.toPascalCase(moduleName.replace(/-/g, " ")),
    ]
  }

  /**
   * Convert PascalCase to snake_case
   */
  private toSnakeCase(str: string): string {
    return str
      .replace(/([A-Z])/g, "_$1")
      .toLowerCase()
      .replace(/^_/, "")
  }

  /**
   * Manual extraction from source code (fallback)
   */
  private async extractDataModelFromSource(moduleName: string): Promise<{
    fields: FieldData[]
    relations: RelationData[]
    entityName: string
    tableName: string
  }> {
    const moduleDir = path.join(this.modulesDir, moduleName)
    const modelsDir = path.join(moduleDir, "models")

    const fields: FieldData[] = []
    const relations: RelationData[] = []
    let entityName = ""
    let tableName = ""
    const seenFields = new Set<string>() // Track seen fields to avoid duplicates

    try {
      const entries = await fs.readdir(modelsDir, { withFileTypes: true })

      for (const entry of entries) {
        if (entry.isFile() && entry.name.endsWith(".ts")) {
          const filePath = path.join(modelsDir, entry.name)
          const content = await fs.readFile(filePath, "utf-8")

          // Parse model.define()
          const modelMatch = content.match(/model\.define\s*\(\s*["']([^"']+)["']/)
          if (modelMatch) {
            // Only set entity/table name from the primary model file (not sub-models)
            // Primary model is typically named after the module
            if (!tableName || entry.name.replace('.ts', '').replace(/-/g, '_') === tableName) {
              tableName = modelMatch[1]
              entityName = this.toPascalCase(tableName)
            }
          }

          // Extract fields with full pattern support
          const fieldPatterns = [
            // id, text, number, boolean, json, dateTime, float, bigNumber
            /(\w+)\s*:\s*model\.(id|text|number|boolean|json|dateTime|float|bigNumber)\([^)]*\)/g,
            // enum with values (single line)
            /(\w+)\s*:\s*model\.enum\s*\(\s*\[([^\]]+)\]/g,
            // enum with values (multiline - status: model\n.enum([...]))
            /(\w+)\s*:\s*model\s*\n\s*\.enum\s*\(\s*\[([^\]]+)\]/gs,
          ]

          for (const pattern of fieldPatterns) {
            const matches = content.matchAll(pattern)
            for (const match of matches) {
              if (pattern.source.includes("enum")) {
                const [, fieldName, enumContent] = match
                // Skip if already seen
                if (seenFields.has(fieldName)) continue
                seenFields.add(fieldName)

                const enumValues = enumContent.split(",")
                  .map(v => v.trim().replace(/['"]/g, "").trim())
                  .filter(v => v.length > 0)

                fields.push({
                  name: fieldName,
                  type: "enum",
                  nullable: content.includes(`${fieldName}.nullable()`),
                  primaryKey: false,
                  searchable: content.includes(`${fieldName}.searchable()`),
                  filterable: true,
                  enumValues
                })
              } else {
                const [, fieldName, fieldType] = match
                // Skip if already seen
                if (seenFields.has(fieldName)) continue
                seenFields.add(fieldName)

                fields.push({
                  name: fieldName,
                  type: this.mapFieldType(fieldType),
                  nullable: content.includes(`${fieldName}.nullable()`) || content.includes(`${fieldName}.optional()`),
                  primaryKey: content.includes(`${fieldName}.primaryKey()`),
                  searchable: content.includes(`${fieldName}.searchable()`),
                  filterable: !["json", "dateTime"].includes(fieldType)
                })
              }
            }
          }

          // Extract relations: hasOne, hasMany, belongsTo, manyToMany
          // Pattern: propertyName: model.hasMany(() => TargetEntity, { mappedBy: "inverseProp" })
          const relationPatterns = [
            // Pattern 1: propertyName: model.hasMany(() => TargetEntity, { mappedBy: "inverse" })
            /(\w+)\s*:\s*model\.(hasOne|hasMany|belongsTo|manyToMany)\s*\(\s*\(\)\s*=>\s*(\w+)\s*,?\s*(?:\{[^}]*mappedBy\s*:\s*["'](\w+)["'][^}]*\})?/g,
            // Pattern 2: propertyName: model.hasMany(() => TargetEntity) - no mappedBy
            /(\w+)\s*:\s*model\.(hasOne|hasMany|belongsTo|manyToMany)\s*\(\s*\(\)\s*=>\s*(\w+)\s*\)/g,
          ]

          const seenRelations = new Set<string>()
          for (const pattern of relationPatterns) {
            const matches = content.matchAll(pattern)
            for (const match of matches) {
              const [, propertyName, relationType, targetEntity, inverseSide] = match
              // Avoid duplicates
              if (seenRelations.has(propertyName)) continue
              seenRelations.add(propertyName)

              relations.push({
                name: propertyName, // Use property name, not relation type
                targetEntity,
                cardinality: this.inferCardinality(relationType),
                inverseSide
              })
            }
          }
        }
      }
    } catch (error) {
      console.warn(`  ‚ö†Ô∏è  Error extracting data model: ${error}`)
    }

    console.log(`  ‚úÖ Extracted: ${fields.length} fields, ${relations.length} relations`)
    return { fields, relations, entityName, tableName }
  }

  /**
    * Extract API routes with comprehensive discovery
    * Searches ALL admin routes and filters by module relevance
    */
   private async extractAPIRoutes(moduleName: string): Promise<APIRouteData[]> {
     const routes: APIRouteData[] = []
     const moduleNameLower = moduleName.toLowerCase()
     const moduleNamePlural = moduleName + "s"

     try {
       // Find ALL route.ts files in admin API
       const allRouteFiles = await this.findFilesRecursive(this.apiDir, /route\.ts$/)

       // Module relevance patterns
       const modulePatterns = [
         moduleNameLower,
         moduleNamePlural,
         moduleName.replace(/s$/, ""),
       ]

       // Cache for validators to avoid re-reading files
       const validatorsCache = new Map<string, { queryFields: string[]; bodyFields: string[] }>()

        for (const file of allRouteFiles) {
          const content = await fs.readFile(file, "utf-8")
          const relativePath = path.relative(this.apiDir, file)

          // Check if this route is directly relevant to our module (strict filtering)
          const isDirectPathMatch = modulePatterns.some(pattern =>
            file.includes(`/${pattern}/`) || file.includes(`/${pattern}s/`)
          )

          // Check if route imports from module (strong indicator)
          const hasModuleImport = modulePatterns.some(pattern => {
            const importPatterns = [
              new RegExp(`from\\s+["']\\.\\.?/+(?:modules/)?${pattern}`, "i"),
              new RegExp(`from\\s+["']\\.\\.?/+(?:modules/)?${pattern}\\/(?:models|services|workflows)`, "i"),
              new RegExp(`from\\s+["']@medusajs\\/medusa[^"]*${pattern}`, "i"),
            ]
            return importPatterns.some(p => p.test(content))
          })

          // Check if route path references module entity (e.g., /partners/:id/...)
          const hasEntityInPath = modulePatterns.some(pattern => {
            const pathPattern = new RegExp(`^/?${pattern}s?\\??|:id\\??/${pattern}`)
            return pathPattern.test(relativePath)
          })

          // Only include if it's a direct path match OR has module import OR entity in path
          const isRelevant = isDirectPathMatch || hasModuleImport || hasEntityInPath

          if (!isRelevant) continue

         // Convert file path to API path
         let apiPath = "/" + relativePath
           .replace("/route.ts", "")
           .replace(/\[(\w+)\]/g, ":$1")
           .replace(/\\/g, "/")

         // Extract HTTP methods
         const methodPatterns = [
           { method: "GET", pattern: /export\s+(?:const\s+GET\s*=\s*async\s*\(|async\s+function\s+GET\s*\()/g },
           { method: "POST", pattern: /export\s+(?:const\s+POST\s*=\s*async\s*\(|async\s+function\s+POST\s*\()/g },
           { method: "PUT", pattern: /export\s+(?:const\s+PUT\s*=\s*async\s*\(|async\s+function\s+PUT\s*\()/g },
           { method: "DELETE", pattern: /export\s+(?:const\s+DELETE\s*=\s*async\s*\(|async\s+function\s+DELETE\s*\()/g },
           { method: "PATCH", pattern: /export\s+(?:const\s+PATCH\s*=\s*async\s*\(|async\s+function\s+PATCH\s*\()/g }
         ]

         const foundMethods = new Set<string>()
         for (const { method, pattern } of methodPatterns) {
           if (pattern.test(content)) {
             foundMethods.add(method)
           }
         }

         // Extract path parameters
         const pathParams = (apiPath.match(/:(\w+)/g) || []).map(p => p.slice(1))

         // Find validators directory
         const validatorsDir = path.join(path.dirname(file), "validators.ts")
         const parentValidatorsDir = path.join(path.dirname(path.dirname(file)), "validators.ts")

         let validatorsContent = ""
         if (await this.fileExists(validatorsDir)) {
           validatorsContent = await fs.readFile(validatorsDir, "utf-8")
         } else if (await this.fileExists(parentValidatorsDir)) {
           validatorsContent = await fs.readFile(parentValidatorsDir, "utf-8")
         }

         // Extract query parameters from Zod schemas
         const queryFields = this.extractSchemaFields(validatorsContent, "Query")
         const bodyFields = this.extractSchemaFields(validatorsContent, "Body")

         // Determine route category based on path
         const routeCategory = this.categorizeRoute(apiPath, moduleName)

         for (const method of foundMethods) {
           // Only GET routes should have query parameters
           const isReadOperation = method === "GET"
           const isWriteOperation = ["POST", "PUT", "PATCH"].includes(method)

           routes.push({
             path: apiPath,
             method,
             description: `${method} ${apiPath}`,
             requiresAuth: true,
             pathParams,
             queryParams: isReadOperation && queryFields.length > 0 ? queryFields : undefined,
             bodyType: isWriteOperation && bodyFields.length > 0 ? bodyFields.join(", ") : undefined,
             responseType: "unknown",
             routeCategory
           })
         }
       }
     } catch (error) {
       console.warn(`  ‚ö†Ô∏è  Error extracting API routes: ${error}`)
     }

     console.log(`  ‚úÖ Extracted: ${routes.length} API endpoints`)
     return routes
   }

   /**
    * Extract field names from Zod schemas in validators
    */
   private extractSchemaFields(validatorsContent: string, schemaType: string): string[] {
     const fields: string[] = []

     if (!validatorsContent) return fields

     // Find all z.object({...}) schemas and extract fields
     const objectSchemas = validatorsContent.matchAll(/(\w+)\s*=\s*z\.object\s*\(\s*\{([\s\S]*?)\}\s*\)\.?\s*(?:export)?/g)

     for (const [, schemaName, objectContent] of objectSchemas) {
       // Check if this schema matches the type we're looking for
       const isQuerySchema = schemaType === "Query" &&
         (schemaName.toLowerCase().includes("query") ||
          schemaName.toLowerCase().includes("list") ||
          schemaName === "ReadDesignsQuerySchema")

       const isBodySchema = schemaType === "Body" &&
         (schemaName.toLowerCase().includes("create") ||
          schemaName.toLowerCase().includes("update") ||
          schemaName.toLowerCase().includes("post") ||
          schemaName.toLowerCase().includes("put") ||
          schemaName.toLowerCase().includes("patch"))

       if ((schemaType === "Query" && !isQuerySchema) || (schemaType === "Body" && !isBodySchema)) {
         continue
       }

       // Extract field names from the object
       const fieldMatches = objectContent.matchAll(/(\w+)\s*:/g)
       for (const [, fieldName] of fieldMatches) {
         // Skip nested object fields (like partner.name, admin.email)
         if (!fieldName.includes(".") && !fields.includes(fieldName)) {
           fields.push(fieldName)
         }
       }

       // Also check for special query fields
       if (isQuerySchema) {
         if (objectContent.includes("fields") && !fields.includes("fields")) fields.push("fields")
         if (objectContent.includes("filters") && !fields.includes("filters")) fields.push("filters")
         if (objectContent.includes("sort") && !fields.includes("sort")) fields.push("sort")
         if (objectContent.includes("limit") && !fields.includes("limit")) fields.push("limit")
         if (objectContent.includes("offset") && !fields.includes("offset")) fields.push("offset")
       }

       if (fields.length > 0) break // Stop after finding the first matching schema
     }

     return fields
   }

   /**
    * Categorize route based on its path pattern
    */
   private categorizeRoute(apiPath: string, moduleName: string): string {
     const patterns = [
       { category: "list", pattern: new RegExp(`^/${moduleName}s?$`) },
       { category: "retrieve", pattern: new RegExp(`^/${moduleName}s?:[a-zA-Z]+$`) },
       { category: "create", pattern: new RegExp(`^/${moduleName}s?$`) },
       { category: "update", pattern: new RegExp(`^/${moduleName}s?:[a-zA-Z]+$`) },
       { category: "delete", pattern: new RegExp(`^/${moduleName}s?:[a-zA-Z]+$`) },
       { category: "action", pattern: new RegExp(`^/${moduleName}s?:[a-zA-Z]+/[a-zA-Z-]+$`) },
       { category: "nested", pattern: new RegExp(`^/${moduleName}s?:[a-zA-Z]+/[a-zA-Z]+$`) },
     ]

     for (const { category, pattern } of patterns) {
       if (pattern.test(apiPath)) {
         return category
       }
     }
     return "other"
   }

  /**
    * Extract workflows with STRICT directory-based attribution
    * Only includes workflows from the module's own workflow directory
    */
   private async extractWorkflows(moduleName: string): Promise<WorkflowData[]> {
     const workflows: WorkflowData[] = []
     const moduleNameLower = moduleName.toLowerCase()

     try {
       // Define VALID workflow directories for this module (strict matching)
       const validWorkflowDirs = [
         path.join(this.workflowsDir, moduleNameLower),                    // /workflows/designs/
         path.join(this.workflowsDir, moduleNameLower + "s"),              // /workflows/partners/
         path.join(this.workflowsDir, moduleNameLower.replace(/_/g, "-")), // /workflows/email-templates/
         path.join(this.workflowsDir, moduleNameLower.replace(/-/g, "_")), // /workflows/etsy_sync/
         path.join(this.workflowsDir, moduleNameLower.replace(/s$/, "")),  // /workflows/design/ (singular)
       ]

       // Collect workflow files from valid directories only
       const workflowFiles: string[] = []

       for (const dir of validWorkflowDirs) {
         try {
           const stat = await fs.stat(dir)
           if (stat.isDirectory()) {
             const filesInDir = await this.findFilesRecursive(dir, /\.ts$/)
             workflowFiles.push(...filesInDir)
           }
         } catch {
           // Directory doesn't exist, skip
         }
       }

       // Also check root-level workflows that match module name pattern exactly
       // e.g., /workflows/create-person.ts for person module
       const rootWorkflowPatterns = [
         `*-${moduleNameLower}.ts`,
         `*-${moduleNameLower}s.ts`,
         `${moduleNameLower}-*.ts`,
       ]

       for (const pattern of rootWorkflowPatterns) {
         try {
           const rootFiles = glob.sync(path.join(this.workflowsDir, pattern))
           if (Array.isArray(rootFiles)) {
             workflowFiles.push(...rootFiles)
           }
         } catch {
           // Pattern didn't match, skip
         }
       }

       // Deduplicate files
       const uniqueFiles = [...new Set(workflowFiles)]

       for (const file of uniqueFiles) {
         const content = await fs.readFile(file, "utf-8")
         const relativePath = path.relative(this.projectRoot, file)

         // Multiple export patterns for workflows
         const workflowExportPatterns = [
           // Pattern 1: export const name = createWorkflow(...)
           /export\s+const\s+(\w+)\s*=\s*createWorkflow\s*\(\s*["']([^"']+)["']/g,
           // Pattern 2: const name = createWorkflow(...) (no export)
           /const\s+(\w+)\s*=\s*createWorkflow\s*\(\s*["']([^"']+)["']/g,
           // Pattern 3: export default createWorkflow(...)
           /export\s+default\s+createWorkflow\s*\(\s*["']([^"']+)["']/g,
         ]

         const foundWorkflows = new Set<string>()

         for (const pattern of workflowExportPatterns) {
           let match
           while ((match = pattern.exec(content)) !== null) {
             const workflowName = match[2] || match[1]
             if (!foundWorkflows.has(workflowName)) {
               foundWorkflows.add(workflowName)
             }
           }
         }

         for (const workflowName of foundWorkflows) {
           const steps: WorkflowStepData[] = []

           // Find step definitions
           const stepMatches = content.matchAll(/createStep\s*\(\s*\{[^}]*id:\s*["']([^"']+)["'][^}]*\}/g)
           for (const stepMatch of stepMatches) {
             steps.push({ id: stepMatch[1] })
           }

           // Find step names from createStep calls
           const stepNameMatches = content.matchAll(/createStep\s*\(\s*["']([^"']+)["'][^,]*,\s*(?:async\s*)?(?:\([^)]*\)|[^,])/g)
           for (const stepMatch of stepNameMatches) {
             const stepName = stepMatch[1]
             if (!steps.find(s => s.id === stepName)) {
               steps.push({ id: stepName })
             }
           }

           // Find input/output schemas
           const inputMatch = content.match(/inputSchema\s*:\s*(\w+)/)
           const outputMatch = content.match(/outputSchema\s*:\s*(\w+)/)

           // Extract input type from workflow.run
           const inputTypeMatch = content.match(/\.run\s*\(\s*\{\s*input:\s*(\w+)/)
           const inputTypeFromRun = inputTypeMatch ? inputTypeMatch[1] : undefined

           // Determine workflow category
           const workflowCategory = this.categorizeWorkflow(workflowName)

           workflows.push({
             name: workflowName,
             description: `Workflow: ${workflowName}`,
             file: relativePath,
             inputType: inputTypeFromRun || inputMatch?.[1],
             outputType: outputMatch?.[1],
             steps,
             workflowCategory
           })
         }
       }
     } catch (error) {
       console.warn(`  ‚ö†Ô∏è  Error extracting workflows: ${error}`)
     }

     console.log(`  ‚úÖ Extracted: ${workflows.length} workflows`)
     return workflows
   }

   /**
    * Categorize workflow based on its name pattern
    */
   private categorizeWorkflow(workflowName: string): string {
     const nameLower = workflowName.toLowerCase()
     if (nameLower.startsWith("create") || nameLower.startsWith("add") || nameLower.startsWith("new")) {
       return "create"
     }
     if (nameLower.startsWith("update") || nameLower.startsWith("edit") || nameLower.startsWith("modify")) {
       return "update"
     }
     if (nameLower.startsWith("delete") || nameLower.startsWith("remove") || nameLower.startsWith("archive")) {
       return "delete"
     }
     if (nameLower.startsWith("list") || nameLower.startsWith("get") || nameLower.startsWith("fetch") || nameLower.startsWith("retrieve")) {
       return "read"
     }
     if (nameLower.startsWith("send") || nameLower.startsWith("notify") || nameLower.startsWith("email")) {
       return "action"
     }
     if (nameLower.includes("task") || nameLower.includes("process") || nameLower.includes("workflow")) {
       return "process"
     }
     return "utility"
   }

  /**
    * Extract module links (defineLink)
    */
   private async extractLinks(moduleName: string): Promise<LinkData[]> {
     const links: LinkData[] = []
     const moduleNameLower = moduleName.toLowerCase()

     try {
       const files = await this.findFilesRecursive(this.linksDir, /\.ts$/)

       for (const file of files) {
         const content = await fs.readFile(file, "utf-8")
         const relativeFile = path.relative(this.projectRoot, file)

         // Extract import statements to map module names
         const importMap: Record<string, string> = {}
         const importRegex = /import\s+(\w+(?:Module)?)\s+from\s+["']([^"']+)["']/g
         let importMatch
         while ((importMatch = importRegex.exec(content)) !== null) {
           const [, importName, importPath] = importMatch
           const pathParts = importPath.split("/")
           const moduleFromPath = pathParts[pathParts.length - 1].replace(/module$/i, "")
           importMap[importName] = moduleFromPath.toLowerCase()
         }

         // Find all defineLink calls (handles multiline)
         const defineLinkRegex = /defineLink\s*\(\s*([\s\S]*?)\s*\)(?=\s*(?:export default|$))/g
         let linkMatch
         while ((linkMatch = defineLinkRegex.exec(content)) !== null) {
           const linkContent = linkMatch[1]
           const configs: Array<{ module: string; entity: string; isList?: boolean; filterable?: string[] }> = []

           // Parse link configurations (handles both simple and complex patterns)
           const configPatterns = [
             // Pattern 1: Simple - Module.linkable.entity
             /(\w+(?:Module)?)\.linkable\.(\w+)/g,
             // Pattern 2: Complex - { linkable: Module.linkable.entity, isList: true, filterable: [...] }
             /\{\s*linkable:\s*(\w+(?:Module)?)\.linkable\.(\w+)(?:[^}]*isList:\s*(true|false))?[^}]*(?:filterable:\s*\[[^\]]*\])?/g
           ]

           for (const pattern of configPatterns) {
             let configMatch
             while ((configMatch = pattern.exec(linkContent)) !== null) {
               const [, moduleName, entityName] = configMatch
               const isListMatch = linkContent.substring(configMatch.index).match(/isList:\s*(true|false)/)
               const filterableMatch = linkContent.substring(configMatch.index).match(/filterable:\s*\[[^\]]*\]/)

               const resolvedModule = importMap[moduleName] || moduleName.toLowerCase().replace(/module$/i, "")
               configs.push({
                 module: resolvedModule,
                 entity: entityName,
                 isList: isListMatch ? isListMatch[1] === "true" : undefined,
                 filterable: filterableMatch ? filterableMatch[0].match(/["']([^"']+)["']/g)?.map(f => f.replace(/["']/g, "")) : undefined
               })
             }
           }

           // If we found exactly 2 configurations, create the link
           if (configs.length >= 2) {
             const source = configs[0]
             const target = configs[1]

             // Check if this link involves our target module
             if (source.module === moduleNameLower || target.module === moduleNameLower) {
               const isSource = source.module === moduleNameLower
               const other = isSource ? target : source
               const otherIsList = isSource ? target.isList : source.isList
               const sourceIsList = isSource ? source.isList : undefined

               // Determine link type
               let linkType: "one-to-one" | "one-to-many" | "many-to-many" = "one-to-one"
               if (source.isList && target.isList) {
                 linkType = "many-to-many"
               } else if (source.isList || target.isList) {
                 linkType = "one-to-many"
               }

               // Extract extra columns
               const extraColumnsMatch = linkContent.match(/database:\s*\{\s*extraColumns:\s*\{([^}]+)\}/)
               const extraColumns: Record<string, { type: string; nullable: boolean }> = {}
               if (extraColumnsMatch) {
                 const columnsStr = extraColumnsMatch[1]
                 const columnMatches = columnsStr.matchAll(/(\w+):\s*\{[^}]*type:\s*["']?(\w+)["']?[^}]*nullable:\s*(true|false)/g)
                 for (const colMatch of columnMatches) {
                   extraColumns[colMatch[1]] = {
                     type: colMatch[2],
                     nullable: colMatch[3] === "true"
                   }
                 }
               }

               // Generate graph query example
               const graphQueryExample = this.generateGraphQueryExample(
                 isSource ? source.entity : target.entity,
                 isSource ? target.entity : source.entity,
                 linkType,
                 isSource ? source.isList : target.isList,
                 isSource ? target.isList : source.isList,
                 isSource ? source.filterable : target.filterable,
                 isSource ? target.filterable : source.filterable
               )

               links.push({
                 sourceModule: source.module,
                 sourceEntity: source.entity,
                 targetModule: target.module,
                 targetEntity: target.entity,
                 definitionFile: relativeFile,
                 linkType,
                 isListSource: source.isList,
                 isListTarget: target.isList,
                 filterableFields: {
                   source: source.filterable || [],
                   target: target.filterable || []
                 },
                 extraColumns: Object.keys(extraColumns).length > 0 ? extraColumns : undefined,
                 graphQueryExample
               })
             }
           }
         }
       }
     } catch (error) {
       console.warn(`  ‚ö†Ô∏è  Error extracting links: ${error}`)
     }

     console.log(`  ‚úÖ Extracted: ${links.length} module links`)
     return links
   }

   /**
    * Generate graph.query example for a link
    */
   private generateGraphQueryExample(
     sourceEntity: string,
     targetEntity: string,
     linkType: "one-to-one" | "one-to-many" | "many-to-many",
     sourceIsList?: boolean,
     targetIsList?: boolean,
     sourceFilterable?: string[],
     targetFilterable?: string[]
   ): string {
     // Helper to create pluralized property name for graph query
     // Handles camelCase entities like "inventoryOrders" -> "inventoryOrders"
     const getPropertyName = (entity: string, isList?: boolean): string => {
       if (!isList) return entity.charAt(0).toLowerCase() + entity.slice(1)
       
       // For list relations, the property name is typically the entity name as-is
       // since Medusa uses the entity name for the link property
       return entity.charAt(0).toLowerCase() + entity.slice(1)
     }

     const sourceProp = sourceEntity.charAt(0).toLowerCase() + sourceEntity.slice(1)
     const targetProp = getPropertyName(targetEntity, true)

     // Determine traversal direction and fields
     let fields: string[] = []
     let filters: string[] = []

     if (linkType === "many-to-many") {
       fields = [`"*"`, `${targetProp}.*`]
       if (targetFilterable && targetFilterable.length > 0) {
         filters.push(`"${targetProp}.${targetFilterable[0]}": "active"`)
       }
     } else if (targetIsList) {
       // Source -> Many targets
       fields = [`"*"`, `${targetProp}.id`, `${targetProp}.${targetFilterable?.[0] || "id"}`]
       if (targetFilterable && targetFilterable.length > 0) {
         filters.push(`"${targetProp}.${targetFilterable[0]}": "active"`)
       }
     } else {
       // One-to-one or source has many
       fields = [`"*"`, `${targetProp}.*`]
     }

      return `// Query ${sourceEntity} with linked ${targetEntity}
const graph = container.resolve(ContainerRegistrationKeys.QUERY)
const result = await graph.graph({
  entity: "${sourceEntity}",
  fields: [${fields.map(f => f).join(", ")}],
  ${filters.length > 0 ? `filters: { ${filters.join(", ")} },` : ""}
  pagination: { limit: 50 }
})
`.trim()
   }

   /**
    * Generate business intelligence for module links
    * Creates natural language query capabilities for RAG systems
    */
   private generateLinkIntelligence(links: LinkData[]): LinkBusinessIntelligence[] {
     return links.map(link => {
       const sourcePlural = this.pluralize(link.sourceEntity)
       const targetPlural = this.pluralize(link.targetEntity)
       const sourceCamel = link.sourceEntity.charAt(0).toLowerCase() + link.sourceEntity.slice(1)
       const targetCamel = link.targetEntity.charAt(0).toLowerCase() + link.targetEntity.slice(1)

       // Generate query capabilities based on link type
       const queryCapabilities = this.generateQueryCapabilities(link, sourcePlural, targetPlural)
       const businessContexts = this.generateBusinessContexts(link, sourcePlural, targetPlural)
       const searchExamples = this.generateSearchExamples(link, sourcePlural, targetPlural)
       const dataFlowPatterns = this.generateDataFlowPatterns(link, sourceCamel, targetCamel)

       return {
         linkDescription: `${link.sourceEntity} ‚Üî ${link.targetEntity} (${link.linkType})`,
         queryCapabilities,
         businessContexts,
         searchExamples,
         dataFlowPatterns
       }
     })
   }

   /**
    * Generate natural language query capabilities
    */
   private generateQueryCapabilities(link: LinkData, sourcePlural: string, targetPlural: string): string[] {
     const queries: string[] = []
     const direction = link.isListTarget ? "from target to source" : "bidirectional"

     queries.push(`How many ${sourcePlural} are linked to ${targetPlural}?`)
     queries.push(`Show me ${sourcePlural} with their associated ${targetPlural}`)
     queries.push(`Which ${targetPlural} are linked to ${link.sourceEntity}?`)

     if (link.linkType === "many-to-many") {
       queries.push(`List all ${sourcePlural} and their ${targetPlural} connections`)
       queries.push(`Find ${targetPlural} that are shared between multiple ${sourcePlural}`)
     } else if (link.linkType === "one-to-many") {
       queries.push(`Count ${targetPlural} per ${link.sourceEntity}`)
       queries.push(`Show ${link.sourceEntity} with multiple ${targetPlural}`)
     }

     return queries
   }

   /**
    * Generate business context descriptions
    */
   private generateBusinessContexts(link: LinkData, sourcePlural: string, targetPlural: string): string[] {
     const contexts: string[] = []

     contexts.push(`${link.sourceEntity} can be associated with ${link.isListTarget ? 'multiple' : 'a single'} ${targetPlural}`)
     contexts.push(`${link.targetEntity}-${link.sourceEntity} relationship enables cross-module queries`)
     contexts.push(`Link type: ${link.linkType} (${link.isListSource ? 'list' : 'single'} to ${link.isListTarget ? 'list' : 'single'})`)

     if (link.extraColumns && Object.keys(link.extraColumns).length > 0) {
       const extraColumnNames = Object.keys(link.extraColumns).join(", ")
       contexts.push(`Additional metadata: ${extraColumnNames}`)
     }

     if (link.filterableFields?.source?.length) {
       contexts.push(`Filterable ${link.sourceEntity} fields: ${link.filterableFields.source.slice(0, 3).join(", ")}`)
     }

     return contexts
   }

   /**
    * Generate search examples for vector/RAG systems
    */
   private generateSearchExamples(link: LinkData, sourcePlural: string, targetPlural: string): string[] {
     const sourceLower = link.sourceEntity.toLowerCase()
     const targetLower = link.targetEntity.toLowerCase()

     return [
       `${sourcePlural} linked to ${targetPlural}`,
       `${targetPlural} for ${link.sourceEntity}`,
       `${link.sourceEntity} ${targetPlural} relationship`,
       `${sourcePlural} with associated ${targetPlural}`,
       `${sourceLower} to ${targetLower} mapping`,
       `find ${targetPlural} by ${sourceLower}`
     ]
   }

   /**
    * Generate data flow pattern examples
    */
   private generateDataFlowPatterns(link: LinkData, sourceCamel: string, targetCamel: string): string[] {
     const patterns: string[] = []

     // Forward traversal
     patterns.push(`Direct query from ${link.sourceEntity} to ${link.targetEntity}`)
     patterns.push(`const ${sourceCamel}With${link.targetEntity} = await graph.graph({ entity: "${link.sourceEntity}", fields: ["*", "${targetCamel}.*"] })`)

     // Reverse traversal
     patterns.push(`Reverse lookup from ${link.targetEntity} to ${link.sourceEntity}`)
     patterns.push(`const ${targetCamel}With${link.sourceEntity} = await graph.graph({ entity: "${link.targetEntity}", fields: ["*", "${sourceCamel}.*"] })`)

     return patterns
   }

   /**
    * Helper to pluralize entity names
    * Handles camelCase and already-plural words
    */
   private pluralize(word: string): string {
     // Check if already plural (common patterns)
     if (word.endsWith("Orders") || word.endsWith("Payments") || word.endsWith("Details") ||
         word.endsWith("Items") || word.endsWith("Lines") || word.endsWith("Sets")) {
       return word
     }

     // Handle camelCase: pluralize only the last word
     const camelMatch = word.match(/^(.*)([A-Z][a-z]+)$/)
     if (camelMatch) {
       const [, prefix, lastWord] = camelMatch
       return prefix + this.pluralizeSingleWord(lastWord)
     }

     return this.pluralizeSingleWord(word)
   }

   /**
    * Pluralize a single word
    */
   private pluralizeSingleWord(word: string): string {
     // Don't double-pluralize
     if (word.endsWith("s") && !word.endsWith("ss")) return word
     // Consonant + y -> ies
     if (word.endsWith("y") && !/[aeiou]y$/i.test(word)) {
       return word.slice(0, -1) + "ies"
     }
     // ch, sh, x, s, z -> es
     if (/(?:ch|sh|x|s|z)$/i.test(word)) {
       return word + "es"
     }
     return word + "s"
   }

   /**
    * Extract subscribers
    */
  private async extractSubscribers(moduleName: string): Promise<SubscriberData[]> {
    const subscribers: SubscriberData[] = []

    try {
      const files = await this.findFilesRecursive(this.subscribersDir, /\.ts$/)

      for (const file of files) {
        const content = await fs.readFile(file, "utf-8")

        // Find subscriber registrations
        const subscriberMatches = content.matchAll(/subscribers\.subscribe\s*\(\s*["']([^"']+)["']\s*,\s*[^,]+,\s*(\w+)/g)
        
        for (const match of subscriberMatches) {
          const [, event, handler] = match
          
          subscribers.push({
            event,
            handler,
            file: path.relative(this.projectRoot, file)
          })
        }
      }
    } catch (error) {
      console.warn(`  ‚ö†Ô∏è  Error extracting subscribers: ${error}`)
    }

    console.log(`  ‚úÖ Extracted: ${subscribers.length} subscribers`)
    return subscribers
  }

  /**
   * Extract service information
   */
  private async extractServices(moduleName: string): Promise<ServiceData[]> {
    const services: ServiceData[] = []

    try {
      const serviceFile = path.join(this.modulesDir, moduleName, "service.ts")
      
      if (await this.fileExists(serviceFile)) {
        const content = await fs.readFile(serviceFile, "utf-8")

        // Find class definition
        const classMatch = content.match(/class\s+(\w+)\s+extends/)
        const extendsMedusaService = content.includes("MedusaService")

        // Find custom methods
        const methodMatches = content.matchAll(/(?:async\s+)?(\w+)\s*\([^)]*\)\s*(?::|\{)/g)
        const methods: string[] = []
        for (const match of methodMatches) {
          const methodName = match[1]
          if (!["constructor", "async", "await"].includes(methodName)) {
            methods.push(methodName)
          }
        }

        if (classMatch || extendsMedusaService) {
          services.push({
            name: classMatch?.[1] || `${moduleName}Service`,
            file: path.relative(this.projectRoot, serviceFile),
            methods,
            extendsMedusaService
          })
        }
      }
    } catch (error) {
      console.warn(`  ‚ö†Ô∏è  Error extracting services: ${error}`)
    }

    console.log(`  ‚úÖ Extracted: ${services.length} services`)
    return services
  }

  /**
   * Generate module description using LLM
   */
  private async generateModuleDescription(
    moduleName: string,
    fields: FieldData[],
    relations: RelationData[]
  ): Promise<string> {
    if (!this.openrouter) {
      return `${moduleName} module for managing ${moduleName} data in the textile commerce platform.`
    }

    const fieldsSummary = fields.slice(0, 5).map(f => 
      `${f.name}: ${f.type}${f.enumValues ? ` (${f.enumValues.join(", ")})` : ""}`
    ).join(", ")

    const prompt = `
Generate a concise description for the ${moduleName} module.

Fields: ${fieldsSummary}
Relations: ${relations.map(r => `${r.name} ‚Üí ${r.targetEntity}`).join(", ")}

Write 2-3 sentences explaining:
- What business entity this module manages
- Its role in the textile commerce platform
- Key relationships with other modules

Respond with only the description, no markdown.
`

    try {
      const { text } = await generateText({
        model: this.openrouter("mistralai/devstral-2512:free"),
        prompt
      })
      return text.trim()
    } catch {
      return `${moduleName} module for managing ${moduleName} data.`
    }
  }

  /**
   * Generate business processes using LLM
   */
  private async generateBusinessProcesses(
    moduleName: string,
    fields: FieldData[],
    relations: RelationData[],
    apiRoutes: APIRouteData[],
    workflows: WorkflowData[]
  ): Promise<BusinessProcess[]> {
    if (!this.openrouter) {
      return this.getMockBusinessProcesses(moduleName)
    }

    const prompt = `
Generate 3-5 realistic business processes for the ${moduleName} module.

Module Details:
- Fields: ${fields.map(f => f.name).join(", ")}
- Relations: ${relations.map(r => `${r.name} ‚Üí ${r.targetEntity}`).join(", ")}
- API Endpoints: ${apiRoutes.length}
- Workflows: ${workflows.map(w => w.name).join(", ")}

For each process:
1. Name: Descriptive action (e.g., "partner_payment_analysis")
2. Description: What it accomplishes
3. Steps: 2-4 logical steps
4. Related modules that might be involved
5. KPIs to measure success

Format as JSON array:
{
  "processes": [{
    "name": "process_name",
    "description": "What it does",
    "steps": [{"name": "step1", "description": "..."}],
    "relatedModules": ["module1", "module2"],
    "kpis": ["kpi1", "kpi2"]
  }]
}

Respond with ONLY valid JSON.
`

    try {
      const { text } = await generateText({
        model: this.openrouter("mistralai/devstral-2512:free"),
        prompt
      })

      const jsonMatch = text.match(/\{[\s\S]*\}/)
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0])
        return parsed.processes || this.getMockBusinessProcesses(moduleName)
      }
      return this.getMockBusinessProcesses(moduleName)
    } catch {
      return this.getMockBusinessProcesses(moduleName)
    }
  }

  /**
   * Find related core entities via Medusa MCP
   */
  private async findRelatedCoreEntities(
    moduleName: string,
    relations: RelationData[]
  ): Promise<string[]> {
    const relatedEntities: string[] = []
    const knownCoreEntities = [
      "order", "product", "customer", "inventory", "payment",
      "region", "currency", "user", "store", "price"
    ]

    for (const relation of relations) {
      const targetLower = relation.targetEntity.toLowerCase()
      for (const core of knownCoreEntities) {
        if (targetLower.includes(core)) {
          relatedEntities.push(core)
        }
      }
    }

    // TODO: Query Medusa MCP for additional related entities
    // This would involve HTTP calls to docs.medusajs.com/mcp

    console.log(`  ‚úÖ Found related core entities: ${relatedEntities.join(", ") || "none"}`)
    return [...new Set(relatedEntities)]
  }

  /**
   * Find external dependencies from relations and links
   */
  private findExternalDependencies(relations: RelationData[], links: LinkData[]): string[] {
    const dependencies = new Set<string>()
    
    for (const relation of relations) {
      dependencies.add(relation.targetEntity)
    }
    
    for (const link of links) {
      dependencies.add(link.targetEntity)
    }

    return Array.from(dependencies)
  }

  /**
   * Identify data flow patterns
   */
  private identifyDataFlowPatterns(
    workflows: WorkflowData[],
    links: LinkData[],
    apiRoutes: APIRouteData[]
  ): string[] {
    const patterns: string[] = []

    if (workflows.length > 0) {
      patterns.push(`Orchestrates ${workflows.length} workflow(s) for complex operations`)
    }

    if (links.length > 0) {
      patterns.push(`Linked to ${links.length} other module(s) via defineLink`)
    }

    const writeMethods = apiRoutes.filter(r => ["POST", "PUT", "PATCH", "DELETE"].includes(r.method))
    if (writeMethods.length > 0) {
      patterns.push(`Supports ${writeMethods.length} write operations via API`)
    }

    const readMethods = apiRoutes.filter(r => r.method === "GET")
    if (readMethods.length > 0) {
      patterns.push(`Provides ${readMethods.length} read endpoints for data retrieval`)
    }

    return patterns
  }

  /**
   * Generate usage examples
   */
  private generateUsageExamples(
    moduleName: string,
    entityName: string,
    apiRoutes: APIRouteData[]
  ): string[] {
    const examples: string[] = []

    // Example: List all entities
    const listRoute = apiRoutes.find(r => r.method === "GET" && !r.pathParams.length)
    if (listRoute) {
      examples.push(`// List all ${moduleName}
const ${moduleName} = await container.resolve("${moduleName.toUpperCase()}_MODULE")
const list = await ${moduleName}.list${entityName}s()`)
    }

    // Example: Retrieve single entity
    const retrieveRoute = apiRoutes.find(r => r.method === "GET" && r.pathParams.includes("id"))
    if (retrieveRoute) {
      examples.push(`// Retrieve single ${moduleName}
const ${moduleName.substring(0, moduleName.length - 1)} = await ${moduleName}.retrieve${entityName}("${moduleName}_123")`)
    }

    return examples
  }

  /**
   * Generate common query examples
   */
  private generateCommonQueries(
    moduleName: string,
    fields: FieldData[],
    relations: RelationData[]
  ): string[] {
    const queries: string[] = []

    // Search queries
    const searchableFields = fields.filter(f => f.searchable)
    if (searchableFields.length > 0) {
      queries.push(`Show me all ${moduleName} where ${searchableFields[0].name} contains "value"`)
    }

    // List with relations
    if (relations.length > 0) {
      queries.push(`List all ${moduleName} with their ${relations[0].targetEntity.toLowerCase()}`)
    }

    // Count queries
    queries.push(`How many ${moduleName} are there?`)

    return queries
  }

  /**
   * Get auto-generated methods from MedusaService
   */
  private getAutoGeneratedMethods(entityName: string): string[] {
    return [
      `create${entityName}s(data)`,
      `list${entityName}s(options?)`,
      `retrieve${entityName}(id)`,
      `update${entityName}s(data)`,
      `delete${entityName}s(ids)`,
      `softDelete${entityName}s(ids)`
    ]
  }

  /**
   * Mock business processes for offline mode
   */
  private getMockBusinessProcesses(moduleName: string): BusinessProcess[] {
    const entity = moduleName.replace(/_/g, " ")
    return [
      {
        name: `${moduleName}_data_analysis`,
        description: `Analyze ${entity} data for insights and trends`,
        steps: [
          { name: "extract_data", description: `Extract all ${entity} records`, inputRequired: true, outputGenerated: true },
          { name: "analyze_patterns", description: "Identify patterns and anomalies", inputRequired: true, outputGenerated: true }
        ],
        relatedModules: [moduleName, "analytics"],
        kpis: ["data_completeness", "analysis_accuracy"]
      },
      {
        name: `${moduleName}_management`,
        description: `Manage ${entity} lifecycle and operations`,
        steps: [
          { name: "create", description: `Create new ${entity}`, inputRequired: true, outputGenerated: true },
          { name: "update", description: `Update existing ${entity}`, inputRequired: true, outputGenerated: true }
        ],
        relatedModules: [moduleName],
        kpis: ["operation_success_rate", "processing_time"]
      }
    ]
  }

  /**
   * Save complete spec to files
   */
  async saveCompleteSpec(spec: CompleteModuleSpec): Promise<void> {
    const specsDir = path.join(this.projectRoot, "specs")
    await fs.mkdir(specsDir, { recursive: true })

    // Save comprehensive JSON
    const jsonFile = path.join(specsDir, `${spec.module}-complete-spec.json`)
    await fs.writeFile(jsonFile, JSON.stringify(spec, null, 2), "utf-8")

    // Generate markdown documentation
    const markdown = this.generateMarkdownDoc(spec)
    const mdFile = path.join(specsDir, `${spec.module}-documentation.md`)
    await fs.writeFile(mdFile, markdown, "utf-8")

    // Generate HTML report
    const htmlFile = path.join(specsDir, "reports", `${spec.module}-complete-report.html`)
    await fs.mkdir(path.dirname(htmlFile), { recursive: true })
    await fs.writeFile(htmlFile, this.generateHTMLReport(spec), "utf-8")

    console.log(`\nüíæ Saved comprehensive specification:`)
    console.log(`  üìÑ JSON: ${jsonFile}`)
    console.log(`  üìù Markdown: ${mdFile}`)
    console.log(`  üìä HTML: ${htmlFile}`)
  }

  /**
   * Generate Markdown documentation
   */
  private generateMarkdownDoc(spec: CompleteModuleSpec): string {
    return `
# ${spec.module} Module - Complete Documentation

## Overview

**Generated:** ${spec.generatedAt}
**Entity:** ${spec.dataModel.entityName}
**Table:** ${spec.dataModel.tableName}

${spec.dataModel.description}

---

## Data Model

### Fields (${spec.dataModel.fields.length})

| Field | Type | Nullable | Searchable | Filterable |
|-------|------|----------|------------|------------|
${spec.dataModel.fields.map(f => 
  `| ${f.name} | ${f.type}${f.enumValues ? ` (${f.enumValues.join(", ")})` : ""} | ${f.nullable ? "Yes" : "No"} | ${f.searchable ? "Yes" : "No"} | ${f.filterable ? "Yes" : "No"} |`
).join("\n")}

### Relations (${spec.dataModel.relations.length})

${spec.dataModel.relations.map(r => 
  `- **${r.name}** ‚Üí ${r.targetEntity} (${r.cardinality})${r.inverseSide ? ` [inverse: ${r.inverseSide}]` : ""}`
).join("\n")}

---

## API Surface

**Total Endpoints:** ${spec.apiSurface.totalEndpoints}

${spec.apiSurface.routes.map(r => 
  `### ${r.method} ${r.path}

- **Auth Required:** ${r.requiresAuth ? "Yes" : "No"}
- **Path Parameters:** ${r.pathParams.join(", ") || "none"}
- **Query Parameters:** ${r.queryParams?.join(", ") || "none"}
- **Body Type:** ${r.bodyType || "N/A"}
`
).join("---\n")}

---

## Workflows (${spec.workflows.count})

${spec.workflows.definitions.map(w => 
  `### ${w.name}

- **File:** ${w.file}
- **Input Type:** ${w.inputType || "unknown"}
- **Output Type:** ${w.outputType || "unknown"}

**Steps:**
${w.steps.map(s => `- ${s.id}`).join("\n")}
`).join("\n---\n")}

---

## Integration Points

### Module Links (${spec.integrationPoints.links.length})

${spec.integrationPoints.links.map(l => 
  `#### ${l.sourceModule}.${l.sourceEntity} ‚Üî ${l.targetModule}.${l.targetEntity}

- **Link Type:** ${l.linkType}
- **Defined in:** ${l.definitionFile}
${l.isListSource ? `- **${l.sourceEntity}**: One-to-many (list)` : ""}
${l.isListTarget ? `- **${l.targetEntity}**: Many-to-one (list)` : ""}
${l.filterableFields?.source?.length ? `- **${l.sourceEntity} Filterable:** ${l.filterableFields.source.join(", ")}` : ""}
${l.filterableFields?.target?.length ? `- **${l.targetEntity} Filterable:** ${l.filterableFields.target.join(", ")}` : ""}
${l.extraColumns ? `- **Extra Columns:** ${Object.keys(l.extraColumns).join(", ")}` : ""}

**Graph Query Example:**
\`\`\`typescript
${l.graphQueryExample}
\`\`\``
).join("\n---\n")}

${spec.integrationPoints.linkIntelligence && spec.integrationPoints.linkIntelligence.length > 0 ? `
### Link Intelligence for RAG

This section provides natural language query capabilities enabled by module links, useful for vector search and RAG systems.

${spec.integrationPoints.linkIntelligence.map((intel, i) => 
  `#### ${intel.linkDescription}

**Natural Language Queries Enabled:**
${intel.queryCapabilities.map(q => `- \`${q}\``).join("\n")}

**Business Context:**
${intel.businessContexts.map(c => `- ${c}`).join("\n")}

**Search Examples for Vector Store:**
${intel.searchExamples.map(s => `- "${s}"`).join("\n")}

**Data Flow Patterns:**
${intel.dataFlowPatterns.map(p => `- ${p}`).join("\n")}
`).join("\n---\n")}
` : ""}

### Subscribers (${spec.integrationPoints.subscribers.length})

${spec.integrationPoints.subscribers.map(s => 
  `- **${s.event}** ‚Üí ${s.handler} (${s.file})`
).join("\n")}

### External Dependencies

${spec.integrationPoints.externalDependencies.map(d => `- ${d}`).join("\n")}

---

## Services

${spec.services.definitions.map(s => 
  `### ${s.name}

- **File:** ${s.file}
- **Extends MedusaService:** ${s.extendsMedusaService ? "Yes" : "No"}

**Auto-generated Methods:**
${spec.services.autoGeneratedMethods.map(m => `- \`${m}\``).join("\n")}
`).join("\n---\n")}

---

## Business Intelligence

### Business Processes (${spec.businessIntelligence.businessProcesses.length})

${spec.businessIntelligence.businessProcesses.map(p => 
  `#### ${p.name}

${p.description}

**Steps:**
${p.steps.map(s => `- **${s.name}**: ${s.description}`).join("\n")}

**Related Modules:** ${p.relatedModules.join(", ")}
**KPIs:** ${p.kpis.join(", ")}
`).join("\n---\n")}

### Related Core Entities

${spec.businessIntelligence.relatedCoreEntities.map(e => `- ${e}`).join("\n") || "None identified"}

### Data Flow Patterns

${spec.businessIntelligence.dataFlowPatterns.map(p => `- ${p}`).join("\n")}

---

## Usage Examples

\`\`\`typescript
${spec.documentation.usageExamples.join("\n\n")}
\`\`\`

---

## Common Queries

${spec.documentation.commonQueries.map(q => `- ${q}`).join("\n")}
`.trim()
  }

  /**
   * Generate HTML report
   */
  private generateHTMLReport(spec: CompleteModuleSpec): string {
    return `
<!DOCTYPE html>
<html>
<head>
    <title>${spec.module} Module - Complete Specification</title>
    <style>
        body { font-family: system-ui, sans-serif; max-width: 1400px; margin: 0 auto; padding: 20px; background: #f5f5f5; }
        .container { background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        h1 { color: #1a1a2e; border-bottom: 3px solid #4361ee; padding-bottom: 10px; }
        h2 { color: #4361ee; margin-top: 30px; }
        h3 { color: #3f37c9; }
        .badge { display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 0.85em; margin: 2px; }
        .badge-get { background: #4caf50; color: white; }
        .badge-post { background: #2196f3; color: white; }
        .badge-put { background: #ff9800; color: white; }
        .badge-delete { background: #f44336; color: white; }
        .badge-patch { background: #9c27b0; color: white; }
        .endpoint { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #4361ee; }
        .field-table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        .field-table th, .field-table td { padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }
        .field-table tr:hover { background: #f5f5f5; }
        .relation { background: #e3f2fd; padding: 10px; border-radius: 6px; margin: 8px 0; }
        .process { background: #fff3e0; padding: 15px; border-radius: 8px; margin: 15px 0; }
        .step { background: #e8f5e9; padding: 8px 12px; border-radius: 4px; margin: 5px 0; }
        code { background: #f5f5f5; padding: 2px 6px; border-radius: 4px; }
        pre { background: #1a1a2e; color: #fff; padding: 15px; border-radius: 8px; overflow-x: auto; }
        .kpi { background: #ffe0b2; padding: 4px 10px; border-radius: 12px; font-size: 0.85em; margin: 3px; display: inline-block; }
        .metadata { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .meta-item { background: #f8f9fa; padding: 15px; border-radius: 8px; }
        .meta-label { font-size: 0.85em; color: #666; }
        .meta-value { font-size: 1.1em; font-weight: 600; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß ${spec.module} Module - Complete Specification</h1>
        <p><em>Generated: ${spec.generatedAt}</em></p>

        <div class="metadata">
            <div class="meta-item">
                <div class="meta-label">Entity</div>
                <div class="meta-value">${spec.dataModel.entityName}</div>
            </div>
            <div class="meta-item">
                <div class="meta-label">Table</div>
                <div class="meta-value">${spec.dataModel.tableName}</div>
            </div>
            <div class="meta-item">
                <div class="meta-label">Fields</div>
                <div class="meta-value">${spec.dataModel.fields.length}</div>
            </div>
            <div class="meta-item">
                <div class="meta-label">Relations</div>
                <div class="meta-value">${spec.dataModel.relations.length}</div>
            </div>
            <div class="meta-item">
                <div class="meta-label">API Endpoints</div>
                <div class="meta-value">${spec.apiSurface.totalEndpoints}</div>
            </div>
            <div class="meta-item">
                <div class="meta-label">Workflows</div>
                <div class="meta-value">${spec.workflows.count}</div>
            </div>
        </div>

        <p><strong>Description:</strong> ${spec.dataModel.description}</p>

        <h2>üìã Data Model</h2>
        <table class="field-table">
            <thead>
                <tr>
                    <th>Field</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Searchable</th>
                    <th>Filterable</th>
                </tr>
            </thead>
            <tbody>
                ${spec.dataModel.fields.map(f => `
                    <tr>
                        <td><strong>${f.name}</strong></td>
                        <td>${f.type}${f.enumValues ? `<br><small>Values: ${f.enumValues.join(", ")}</small>` : ""}</td>
                        <td>${f.nullable ? "‚úì" : "‚úó"}</td>
                        <td>${f.searchable ? "‚úì" : "‚úó"}</td>
                        <td>${f.filterable ? "‚úì" : "‚úó"}</td>
                    </tr>
                `).join("")}
            </tbody>
        </table>

        <h2>üîó Relations</h2>
        ${spec.dataModel.relations.map(r => `
            <div class="relation">
                <strong>${r.name}</strong> ‚Üí ${r.targetEntity}
                <span class="badge" style="background: #e3f2fd; color: #1565c0;">${r.cardinality}</span>
                ${r.inverseSide ? `<br><small>Inverse: ${r.inverseSide}</small>` : ""}
            </div>
        `).join("")}

        <h2>üåê API Endpoints (${spec.apiSurface.totalEndpoints})</h2>
        ${spec.apiSurface.routes.map(r => `
            <div class="endpoint">
                <span class="badge badge-${r.method.toLowerCase()}">${r.method}</span>
                <code>${r.path}</code>
                ${r.pathParams.length ? `<br><small>Path params: ${r.pathParams.join(", ")}</small>` : ""}
                ${r.queryParams ? `<br><small>Query params: ${r.queryParams.join(", ")}</small>` : ""}
            </div>
        `).join("")}

        <h2>‚öôÔ∏è Workflows (${spec.workflows.count})</h2>
        ${spec.workflows.definitions.map(w => `
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 10px 0;">
                <h3>${w.name}</h3>
                <p>File: ${w.file}</p>
                ${w.steps.length > 0 ? `<p><strong>Steps:</strong> ${w.steps.map(s => s.id).join(" ‚Üí ")}</p>` : ""}
            </div>
        `).join("")}

        <h2>üîó Module Links (${spec.integrationPoints.links.length})</h2>
        ${spec.integrationPoints.links.length > 0 ? spec.integrationPoints.links.map(l => `
            <div class="relation" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                <strong>${l.sourceModule}.${l.sourceEntity}</strong> ‚Üî <strong>${l.targetModule}.${l.targetEntity}</strong>
                <br><small>Type: ${l.linkType}</small>
                ${l.isListSource ? `<br><small>${l.sourceEntity}: list</small>` : ""}
                ${l.isListTarget ? `<br><small>${l.targetEntity}: list</small>` : ""}
                ${l.extraColumns ? `<br><small>Extra columns: ${Object.keys(l.extraColumns).join(", ")}</small>` : ""}
                <br><small>File: ${l.definitionFile}</small>
                ${l.graphQueryExample ? `
                <details>
                    <summary style="cursor: pointer; color: #4361ee; margin-top: 10px;">Show Graph Query Example</summary>
                    <pre style="background: #1a1a2e; color: #fff; padding: 10px; border-radius: 4px; margin-top: 5px; overflow-x: auto; font-size: 0.85em;"><code>${l.graphQueryExample}</code></pre>
                </details>
                ` : ""}
            </div>
        `).join("") : "<p>No module links defined</p>"}

        ${spec.integrationPoints.linkIntelligence && spec.integrationPoints.linkIntelligence.length > 0 ? `
        <h2>üß† Link Intelligence for RAG</h2>
        ${spec.integrationPoints.linkIntelligence.map(intel => `
            <div class="process" style="background: #e8f5e9;">
                <h3>${intel.linkDescription}</h3>
                <p><strong>Natural Language Queries:</strong></p>
                <ul>
                    ${intel.queryCapabilities.map(q => `<li><code>${q}</code></li>`).join("")}
                </ul>
                <p><strong>Business Context:</strong></p>
                <ul>
                    ${intel.businessContexts.map(c => `<li>${c}</li>`).join("")}
                </ul>
                <p><strong>Search Examples:</strong></p>
                <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                    ${intel.searchExamples.map(s => `<span class="badge" style="background: #e3f2fd; color: #1565c0;">${s}</span>`).join("")}
                </div>
            </div>
        `).join("")}
        ` : ""}

        <h2>üì° Subscribers</h2>
        ${spec.integrationPoints.subscribers.length > 0 ? spec.integrationPoints.subscribers.map(s => `
            <div style="background: #f8f9fa; padding: 8px 12px; border-radius: 4px; margin: 5px 0;">
                <strong>${s.event}</strong> ‚Üí ${s.handler}
            </div>
        `).join("") : "<p>No subscribers found</p>"}

        <h2>üíº Business Intelligence</h2>
        ${spec.businessIntelligence.businessProcesses.map(p => `
            <div class="process">
                <h3>${p.name}</h3>
                <p>${p.description}</p>
                <strong>Steps:</strong>
                ${p.steps.map(s => `<div class="step">${s.name}: ${s.description}</div>`).join("")}
                <br>
                <strong>Related:</strong> ${p.relatedModules.join(", ")}
                <br>
                <strong>KPIs:</strong> ${p.kpis.map(k => `<span class="kpi">${k}</span>`).join(" ")}
            </div>
        `).join("")}

        <h2>üìä Data Flow Patterns</h2>
        <ul>
            ${spec.businessIntelligence.dataFlowPatterns.map(p => `<li>${p}</li>`).join("")}
        </ul>

        <h2>üíª Usage Examples</h2>
        <pre><code>${spec.documentation.usageExamples.join("\n\n")}</code></pre>

        <h2>‚ùì Common Queries</h2>
        <ul>
            ${spec.documentation.commonQueries.map(q => `<li>${q}</li>`).join("")}
        </ul>
    </div>
</body>
</html>
    `.trim()
  }

  // Helper methods
  private async fileExists(filepath: string): Promise<boolean> {
    try { await fs.access(filepath); return true } catch { return false }
  }

  private async directoryExists(dirpath: string): Promise<boolean> {
    try { const stat = await fs.stat(dirpath); return stat.isDirectory() } catch { return false }
  }

  private async findFilesRecursive(dir: string, pattern: RegExp): Promise<string[]> {
    const files: string[] = []
    try {
      const entries = await fs.readdir(dir, { withFileTypes: true })
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name)
        if (entry.isDirectory()) {
          files.push(...await this.findFilesRecursive(fullPath, pattern))
        } else if (entry.isFile() && pattern.test(entry.name)) {
          files.push(fullPath)
        }
      }
    } catch { /* Ignore errors */ }
    return files
  }

  private toPascalCase(str: string): string {
    return str.replace(/(^|_)([a-z])/g, (_, __, char) => char.toUpperCase())
  }

  private mapFieldType(type: string): string {
    const map: Record<string, string> = {
      "id": "string", "text": "string", "number": "number",
      "boolean": "boolean", "dateTime": "Date", "json": "JSON",
      "float": "number", "bigNumber": "number"
    }
    return map[type] || type
  }

  private inferCardinality(relationType: string): string {
    const map: Record<string, string> = {
      "hasOne": "one-to-one", "hasMany": "one-to-many",
      "belongsTo": "many-to-one", "manyToMany": "many-to-many"
    }
    return map[relationType] || "one-to-one"
  }
}

// CLI Interface
async function main() {
  const args = process.argv.slice(2)
  if (args.length === 0) {
    console.log(`
üîß Enhanced RAG Module Spec Generator

Comprehensive module analysis including:
- Data models (fields, relations, enums)
- API routes with schemas
- Workflow definitions
- Module links (defineLink)
- Subscribers and events
- Service methods
- Business process intelligence
- Usage examples and common queries

Usage:
  node generate-enhanced-specs.js <module-name>
  node generate-enhanced-specs.js partner
  node generate-enhanced-specs.js all

Examples:
  node generate-enhanced-specs.js partner
  node generate-enhanced-specs.js design

Outputs saved to: specs/ directory
    `.trim())
    process.exit(1)
  }

  const generator = new EnhancedModuleSpecGenerator()
  const moduleName = args[0]

  if (moduleName === "all") {
    const modulesDir = path.join(process.cwd(), "src/modules")
    const modules = await fs.readdir(modulesDir)
    
    console.log(`\nüöÄ Generating comprehensive specs for all modules...`)
    for (const module of modules) {
      try {
        const spec = await generator.generateCompleteSpec(module)
        await generator.saveCompleteSpec(spec)
        console.log(`‚úÖ Completed: ${module}`)
      } catch (error) {
        console.error(`‚ùå Failed: ${module}`, error)
      }
    }
    console.log("\nüéâ All specs generated!")
  } else {
    console.log(`\nüöÄ Generating comprehensive spec for: ${moduleName}`)
    const spec = await generator.generateCompleteSpec(moduleName)
    await generator.saveCompleteSpec(spec)
    console.log("\nüéâ Spec generated successfully!")
  }
}

if (require.main === module) {
  main().catch(console.error)
}
