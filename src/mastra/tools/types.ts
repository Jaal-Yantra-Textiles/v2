/**
 * Enhanced Types for Multi-Step Query Execution
 *
 * This file contains all the interfaces for the evaluated multi-step
 * execution system, including entity classification, step evaluation,
 * and enhanced query plans.
 */

// ============================================
// ENTITY CLASSIFICATION
// ============================================

/**
 * Classification of an entity - whether it's a Core Medusa entity
 * (accessed via HTTP API) or a Custom module (accessed via container.resolve)
 */
export interface EntityClassification {
  entityName: string
  isCore: boolean
  executionMethod: "http" | "module"
  apiPath?: string // For core: "/admin/customers"
  moduleKey?: string // For custom: "DESIGN_MODULE"
  modelName?: string // For custom: "Design" (used for method generation)
  validRelations: string[]
}

/**
 * Expected response format for an entity query
 */
export interface ResponseExpectation {
  format: "array" | "object"
  wrapperKey?: string // e.g., "customers" for { customers: [...] }
  minimumFields: string[] // Fields that MUST exist on each item
}

/**
 * Validation criteria for a query step
 */
export interface StepValidation {
  requireNonEmpty: boolean // Must have at least 1 result
  requireFields: string[] // Required fields on each item
  extractField?: string // Field to extract for next step
  extractValidation?: {
    notNull: boolean
    type?: "string" | "number"
  }
}

// ============================================
// ENHANCED QUERY STEP
// ============================================

/**
 * Basic query step (generated by LLM)
 */
export interface QueryStep {
  step: number
  entity: string
  operation: "list" | "retrieve" | "listAndCount"
  filters: Record<string, any>
  relations?: string[]
  extract?: string // Field to extract for next step (e.g., "id")
  linkedFields?: string[] // For Query.graph linked module fields (e.g., ["inventory_item.*"])
  fields?: string[] // Custom fields for link table queries
  executionMethod?: "http" | "module" | "graph" // Hint for execution strategy
}

/**
 * Workflow action (for triggering workflows via API)
 */
export interface WorkflowAction {
  type: "workflow"
  endpoint: string
  method: "POST" | "PUT" | "PATCH"
  body?: Record<string, any>
  workflowName?: string
}

/**
 * Enhanced query step with classification and validation
 */
export interface EnhancedQueryStep extends QueryStep {
  // Classification (populated from entity registry)
  classification: EntityClassification

  // What response format to expect
  responseExpectation: ResponseExpectation

  // How to validate success
  validation: StepValidation

  // Human-readable description for logging
  description: string

  // Which steps this depends on (for $N references)
  dependsOn: number[]
}

// ============================================
// QUERY PLAN
// ============================================

/**
 * Basic query plan (from LLM)
 */
export interface QueryPlan {
  steps: QueryStep[]
  finalEntity: string // The entity the user ultimately wants
  explanation: string // Brief explanation of the plan
  action?: WorkflowAction // Optional workflow action to trigger after steps
}

/**
 * Enhanced query plan with classification metadata
 */
export interface EnhancedQueryPlan {
  steps: EnhancedQueryStep[]
  finalEntity: string
  explanation: string

  // Metadata about entities involved
  coreEntitiesInvolved: string[]
  customEntitiesInvolved: string[]
}

// ============================================
// STEP EVALUATION
// ============================================

/**
 * Data quality score for a step result
 */
export type DataQuality = "excellent" | "good" | "acceptable" | "poor" | "failed"

/**
 * Recommendation after evaluating a step
 */
export type EvaluationRecommendation = "continue" | "retry" | "abort" | "skip"

/**
 * Error codes for step failures
 */
export type StepErrorCode =
  | "NO_RESULTS"
  | "EXTRACTION_FAILED"
  | "API_ERROR"
  | "VALIDATION_FAILED"
  | "TIMEOUT"

/**
 * Retry strategy when a step fails
 */
export interface RetryStrategy {
  adjustFilters?: Record<string, any>
  broaderSearch?: boolean
  removeFilters?: string[]
}

/**
 * Evaluation result for a single step
 */
export interface StepEvaluationResult {
  success: boolean
  dataQuality: DataQuality

  evaluatedCriteria: {
    hasResults: boolean
    resultCount: number
    requiredFieldsPresent: boolean
    extractedValueValid: boolean
  }

  recommendation: EvaluationRecommendation

  retryStrategy?: RetryStrategy

  error?: {
    code: StepErrorCode
    message: string
  }

  summary: string
}

// ============================================
// EXECUTION RESULTS
// ============================================

/**
 * Result from a service call
 */
export interface ServiceCallResult {
  success: boolean
  data?: any
  error?: string
  entity: string
  method: string
  statusCode?: number
}

/**
 * Record of a single step's execution
 */
export interface ExecutionStep {
  step: number
  entity: string
  operation: string
  filters: Record<string, any>
  result: ServiceCallResult
  resolvedValue?: any // The extracted value for use in subsequent steps
  evaluation?: StepEvaluationResult
  attempts: number
  durationMs: number
}

/**
 * Evaluation summary for the entire plan execution
 */
export interface EvaluationSummary {
  successful: number
  failed: number
  retried: number
  skipped: number
}

/**
 * Data lineage - how data flowed between steps
 */
export interface DataLineage {
  stepNumber: number
  entity: string
  extractedField?: string
  extractedValue?: any
  usedInStep?: number
}

/**
 * Complete result of executing an enhanced query plan
 */
export interface EnhancedPlanExecutionResult {
  success: boolean
  finalResult: ServiceCallResult | null
  executionSteps: ExecutionStep[]
  plan: EnhancedQueryPlan

  // Enhanced metadata
  qualityScore: number // 0-100 overall quality
  evaluationSummary: EvaluationSummary
  dataLineage: DataLineage[]

  error?: string
  totalDurationMs: number
}

// ============================================
// CONSTANTS
// ============================================

export const MAX_RETRIES = 2
export const DEFAULT_STEP_TIMEOUT_MS = 10000

/**
 * Quality score weights for calculating overall quality
 */
export const QUALITY_WEIGHTS: Record<DataQuality, number> = {
  excellent: 100,
  good: 80,
  acceptable: 60,
  poor: 30,
  failed: 0,
}
