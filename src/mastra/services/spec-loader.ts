/**
 * Spec Loader Service
 *
 * Loads and caches module specifications generated by generate-enhanced-specs.ts.
 * Provides rich entity metadata including fields, relations, enums, and links
 * that can be used by the query planner and dynamic schema service.
 *
 * Key features:
 * - Loads specs from specs/ directory
 * - Caches specs in memory with TTL
 * - On-the-fly spec generation when file not found
 * - Provides LLM-friendly context for query planning
 * - Integrates with embedding service for semantic search
 */

// @ts-nocheck
import * as fs from "fs/promises"
import * as path from "path"
import * as glob from "glob"

// Types from container introspection (to avoid circular dependency)
interface DiscoveredModule {
  name: string
  entityName: string
  type: "core" | "custom"
  description: string
  queryable: boolean
  fields?: Array<{ name: string; type: string; filterable: boolean }>
  serviceMethods?: string[]
}

// ─── Types ───────────────────────────────────────────────────────────────────

export interface FieldSpec {
  name: string
  type: string
  nullable: boolean
  primaryKey: boolean
  searchable: boolean
  filterable: boolean
  enumValues?: string[]
  defaultValue?: string
}

export interface RelationSpec {
  name: string
  targetEntity: string
  cardinality: string
  inverseSide?: string
}

export interface WorkflowSpec {
  name: string
  description: string
  file: string
  inputType?: string
  outputType?: string
  steps: Array<{ id: string; description?: string }>
  workflowCategory?: string
}

export interface APIRouteSpec {
  path: string
  method: string
  description: string
  requiresAuth: boolean
  pathParams: string[]
  queryParams?: string[]
  bodyType?: string
  responseType?: string
  routeCategory?: string
}

export interface LinkSpec {
  sourceModule: string
  sourceEntity: string
  targetModule: string
  targetEntity: string
  definitionFile: string
  linkType: "one-to-one" | "one-to-many" | "many-to-many"
  isListSource?: boolean
  isListTarget?: boolean
  filterableFields?: {
    source: string[]
    target: string[]
  }
  extraColumns?: Record<string, { type: string; nullable: boolean }>
  graphQueryExample?: string
}

export interface LinkIntelligence {
  linkDescription: string
  queryCapabilities: string[]
  businessContexts: string[]
  searchExamples: string[]
  dataFlowPatterns: string[]
}

export interface ModuleSpec {
  module: string
  generatedAt: string
  dataModel: {
    entityName: string
    tableName: string
    description: string
    fields: FieldSpec[]
    relations: RelationSpec[]
  }
  apiSurface: {
    routes: APIRouteSpec[]
    totalEndpoints: number
  }
  workflows: {
    definitions: WorkflowSpec[]
    count: number
  }
  integrationPoints: {
    links: LinkSpec[]
    subscribers: any[]
    externalDependencies: string[]
    linkIntelligence?: LinkIntelligence[]
  }
  services: {
    definitions: any[]
    autoGeneratedMethods: string[]
  }
  businessIntelligence: {
    businessProcesses: any[]
    relatedCoreEntities: string[]
    dataFlowPatterns: string[]
  }
  documentation: {
    usageExamples: string[]
    commonQueries: string[]
  }
}

// ─── Configuration ───────────────────────────────────────────────────────────

const SPECS_DIR = process.env.SPECS_DIR || path.join(process.cwd(), "specs")
const CACHE_TTL_MS = 5 * 60 * 1000 // 5 minutes
const DB_CONNECTION_STRING = process.env.DATABASE_URL || process.env.MASTRA_DATABASE_URL

// ─── Cache ───────────────────────────────────────────────────────────────────

interface CachedSpec {
  spec: ModuleSpec
  loadedAt: number
}

const specCache = new Map<string, CachedSpec>()
let allSpecsLoadedAt: number | null = null

// ─── Database Layer ─────────────────────────────────────────────────────────

let dbPool: any = null
let dbAvailable: boolean | null = null

async function getDbPool() {
  if (dbPool) return dbPool
  if (dbAvailable === false) return null
  if (!DB_CONNECTION_STRING) {
    dbAvailable = false
    return null
  }

  try {
    const { Pool } = await import("pg")
    dbPool = new Pool({ connectionString: DB_CONNECTION_STRING, max: 3 })
    // Test the connection and table existence
    await dbPool.query("SELECT 1 FROM spec_doc LIMIT 1")
    dbAvailable = true
    console.log("[spec-loader] DB spec_doc table available")
    return dbPool
  } catch {
    dbAvailable = false
    dbPool = null
    return null
  }
}

async function loadSpecFromDB(moduleName: string, specType: string = "module"): Promise<ModuleSpec | null> {
  const pool = await getDbPool()
  if (!pool) return null

  try {
    const result = await pool.query(
      `SELECT content FROM spec_doc WHERE module_name = $1 AND spec_type = $2 AND deleted_at IS NULL LIMIT 1`,
      [moduleName, specType]
    )
    if (result.rows.length > 0) {
      return result.rows[0].content as ModuleSpec
    }
  } catch (err) {
    console.warn(`[spec-loader] DB query failed for ${moduleName}:`, err)
  }

  return null
}

async function loadAllSpecsFromDB(): Promise<Map<string, ModuleSpec> | null> {
  const pool = await getDbPool()
  if (!pool) return null

  try {
    const result = await pool.query(
      `SELECT module_name, content FROM spec_doc WHERE spec_type = 'module' AND deleted_at IS NULL`
    )
    if (result.rows.length === 0) return null

    const specs = new Map<string, ModuleSpec>()
    for (const row of result.rows) {
      specs.set(row.module_name, row.content as ModuleSpec)
    }
    return specs
  } catch (err) {
    console.warn("[spec-loader] DB loadAllSpecs failed:", err)
  }

  return null
}

// ─── On-the-fly Spec Generation ──────────────────────────────────────────────

const SRC_DIR = process.env.SRC_DIR || path.join(process.cwd(), "src")

/**
 * Generate a module spec on-the-fly by analyzing source code.
 * Used as fallback when no pre-generated spec file exists.
 */
async function generateSpecFromContainer(moduleName: string): Promise<ModuleSpec | null> {
  try {
    const normalizedName = singularize(moduleName.toLowerCase())
    const moduleDir = await findModuleDirectory(normalizedName)

    if (!moduleDir) {
      console.warn(`[spec-loader] Could not find module directory for: ${moduleName}`)
      return null
    }

    console.log(`[spec-loader] Generating spec from source for: ${moduleName} (dir: ${moduleDir})`)

    // Extract data from source files
    const fields = await extractFieldsFromModels(moduleDir)
    const relations = await extractRelationsFromModels(moduleDir)
    const serviceMethods = await extractServiceMethods(moduleDir)
    const apiRoutes = await extractApiRoutes(moduleName)

    // Build the spec
    const spec: ModuleSpec = {
      module: moduleName,
      generatedAt: new Date().toISOString(),
      dataModel: {
        entityName: pluralize(normalizedName),
        tableName: normalizedName,
        description: `Auto-generated spec for ${moduleName}`,
        fields,
        relations,
      },
      apiSurface: {
        routes: apiRoutes,
        totalEndpoints: apiRoutes.length,
      },
      workflows: {
        definitions: [],
        count: 0,
      },
      integrationPoints: {
        links: [],
        subscribers: [],
        externalDependencies: [],
      },
      services: {
        definitions: [],
        autoGeneratedMethods: serviceMethods,
      },
      businessIntelligence: {
        businessProcesses: [],
        relatedCoreEntities: [],
        dataFlowPatterns: [],
      },
      documentation: {
        usageExamples: [],
        commonQueries: generateCommonQueries(moduleName, fields, relations),
      },
    }

    return spec
  } catch (error) {
    console.error(`[spec-loader] Failed to generate spec for ${moduleName}:`, error)
    return null
  }
}

/**
 * Find the module directory by searching common locations.
 */
async function findModuleDirectory(moduleName: string): Promise<string | null> {
  const possiblePaths = [
    path.join(SRC_DIR, "modules", moduleName),
    path.join(SRC_DIR, "modules", pluralize(moduleName)),
    path.join(SRC_DIR, "modules", moduleName.replace(/_/g, "-")),
    path.join(SRC_DIR, "modules", pluralize(moduleName.replace(/_/g, "-"))),
  ]

  for (const dirPath of possiblePaths) {
    try {
      const stat = await fs.stat(dirPath)
      if (stat.isDirectory()) {
        return dirPath
      }
    } catch {
      continue
    }
  }

  return null
}

/**
 * Extract fields from model files using regex patterns.
 */
async function extractFieldsFromModels(moduleDir: string): Promise<FieldSpec[]> {
  const fields: FieldSpec[] = []
  const seenFields = new Set<string>()

  try {
    const modelDir = path.join(moduleDir, "models")
    const modelFiles = await glob.glob("*.ts", { cwd: modelDir })

    for (const file of modelFiles) {
      const content = await fs.readFile(path.join(modelDir, file), "utf-8")

      // Pattern: fieldName: model.type()
      const fieldPattern = /(\w+)\s*:\s*model\.(id|text|number|boolean|bigNumber|dateTime|json|enum)\s*\(/g
      let match

      while ((match = fieldPattern.exec(content)) !== null) {
        const [, fieldName, fieldType] = match

        if (seenFields.has(fieldName)) continue
        seenFields.add(fieldName)

        // Check for enum values
        let enumValues: string[] | undefined
        if (fieldType === "enum") {
          const enumMatch = content.slice(match.index).match(/enum\s*\(\s*\[([^\]]+)\]/)
          if (enumMatch) {
            enumValues = enumMatch[1]
              .split(",")
              .map(v => v.trim().replace(/['"]/g, ""))
              .filter(Boolean)
          }
        }

        fields.push({
          name: fieldName,
          type: mapFieldType(fieldType),
          nullable: content.slice(match.index, match.index + 200).includes(".nullable()"),
          primaryKey: fieldName === "id",
          searchable: ["name", "title", "description", "code"].includes(fieldName.toLowerCase()),
          filterable: fieldType !== "json",
          enumValues,
        })
      }
    }
  } catch {
    // Return empty if models dir doesn't exist
  }

  // Ensure id field exists
  if (!seenFields.has("id")) {
    fields.unshift({
      name: "id",
      type: "string",
      nullable: false,
      primaryKey: true,
      searchable: false,
      filterable: true,
    })
  }

  return fields
}

/**
 * Extract relations from model files.
 */
async function extractRelationsFromModels(moduleDir: string): Promise<RelationSpec[]> {
  const relations: RelationSpec[] = []

  try {
    const modelDir = path.join(moduleDir, "models")
    const modelFiles = await glob.glob("*.ts", { cwd: modelDir })

    for (const file of modelFiles) {
      const content = await fs.readFile(path.join(modelDir, file), "utf-8")

      // Pattern: propertyName: model.hasMany(() => TargetEntity)
      const relationPattern = /(\w+)\s*:\s*model\.(hasOne|hasMany|belongsTo|manyToMany)\s*\(\s*\(\)\s*=>\s*(\w+)/g
      let match

      while ((match = relationPattern.exec(content)) !== null) {
        const [, propertyName, relationType, targetEntity] = match

        relations.push({
          name: propertyName,
          targetEntity,
          cardinality: inferCardinality(relationType),
        })
      }
    }
  } catch {
    // Return empty if models dir doesn't exist
  }

  return relations
}

/**
 * Extract service methods from service files.
 */
async function extractServiceMethods(moduleDir: string): Promise<string[]> {
  const methods: string[] = []

  try {
    const serviceDir = path.join(moduleDir, "service.ts")
    const content = await fs.readFile(serviceDir, "utf-8")

    // Check for MedusaService pattern
    if (content.includes("MedusaService")) {
      // Extract models from MedusaService({Model1, Model2})
      const serviceMatch = content.match(/MedusaService\s*\(\s*\{([^}]+)\}/)
      if (serviceMatch) {
        const models = serviceMatch[1]
          .split(",")
          .map(m => m.trim())
          .filter(Boolean)

        for (const model of models) {
          const singular = singularizeSingleWord(model)
          const plural = pluralizeSingleWord(model)
          methods.push(
            `list${plural}`,
            `retrieve${singular}`,
            `create${plural}`,
            `update${plural}`,
            `delete${plural}`
          )
        }
      }
    }

    // Extract custom async methods
    const methodPattern = /async\s+(\w+)\s*\([^)]*\)/g
    let match
    while ((match = methodPattern.exec(content)) !== null) {
      if (!methods.includes(match[1]) && !match[1].startsWith("_")) {
        methods.push(match[1])
      }
    }
  } catch {
    // Return empty if service doesn't exist
  }

  return methods
}

/**
 * Extract API routes from api directory.
 */
async function extractApiRoutes(moduleName: string): Promise<APIRouteSpec[]> {
  const routes: APIRouteSpec[] = []
  const normalizedName = moduleName.replace(/_/g, "-")

  const apiPaths = [
    path.join(SRC_DIR, "api", "admin", normalizedName),
    path.join(SRC_DIR, "api", "admin", pluralize(normalizedName)),
    path.join(SRC_DIR, "api", "store", normalizedName),
    path.join(SRC_DIR, "api", "store", pluralize(normalizedName)),
  ]

  for (const apiPath of apiPaths) {
    try {
      const routeFiles = await glob.glob("**/route.ts", { cwd: apiPath })

      for (const file of routeFiles) {
        const content = await fs.readFile(path.join(apiPath, file), "utf-8")
        const relativePath = path.dirname(file)

        // Build API path from file location
        const apiPrefix = apiPath.includes("/admin/") ? "/admin" : "/store"
        const routePath = `${apiPrefix}/${normalizedName}${relativePath === "." ? "" : "/" + relativePath.replace(/\[(\w+)\]/g, ":$1")}`

        // Extract HTTP methods
        const httpMethods = ["GET", "POST", "PUT", "DELETE", "PATCH"]
        for (const method of httpMethods) {
          if (new RegExp(`export\\s+(async\\s+)?function\\s+${method}`, "i").test(content)) {
            routes.push({
              path: routePath,
              method,
              description: `${method} ${routePath}`,
              requiresAuth: apiPath.includes("/admin/"),
              pathParams: (routePath.match(/:(\w+)/g) || []).map(p => p.slice(1)),
            })
          }
        }
      }
    } catch {
      continue
    }
  }

  return routes
}

/**
 * Generate common queries based on fields and relations.
 */
function generateCommonQueries(moduleName: string, fields: FieldSpec[], relations: RelationSpec[]): string[] {
  const queries: string[] = []
  const entityName = pluralize(singularize(moduleName))

  queries.push(`List all ${entityName}`)

  // Status-based queries
  const statusField = fields.find(f => f.name === "status" && f.enumValues)
  if (statusField && statusField.enumValues) {
    for (const status of statusField.enumValues.slice(0, 3)) {
      queries.push(`Find ${entityName} with status "${status}"`)
    }
  }

  // Relation-based queries
  for (const rel of relations.slice(0, 2)) {
    queries.push(`Get ${entityName} with their ${rel.name}`)
  }

  return queries
}

/**
 * Map Medusa model types to simple types.
 */
function mapFieldType(medusaType: string): string {
  const typeMap: Record<string, string> = {
    id: "string",
    text: "string",
    number: "number",
    boolean: "boolean",
    bigNumber: "number",
    dateTime: "Date",
    json: "object",
    enum: "string",
  }
  return typeMap[medusaType] || "unknown"
}

/**
 * Infer relation cardinality from Medusa relation type.
 */
function inferCardinality(relationType: string): string {
  const cardinalityMap: Record<string, string> = {
    hasOne: "one-to-one",
    hasMany: "one-to-many",
    belongsTo: "many-to-one",
    manyToMany: "many-to-many",
  }
  return cardinalityMap[relationType] || "unknown"
}

// ─── Public API ──────────────────────────────────────────────────────────────

/**
 * Load a single module spec by name.
 * Handles both singular and plural naming conventions.
 *
 * @param moduleName - The module name (e.g., "production_runs", "designs", "design", "production_run")
 * @returns The module spec or null if not found
 */
export async function loadModuleSpec(
  moduleName: string
): Promise<ModuleSpec | null> {
  // Normalize the module name - check cache with all variations
  const variations = getModuleNameVariations(moduleName)

  for (const variant of variations) {
    const cached = specCache.get(variant)
    if (cached && Date.now() - cached.loadedAt < CACHE_TTL_MS) {
      return cached.spec
    }
  }

  // Try loading from database first (populated by CI)
  for (const variant of variations) {
    const dbSpec = await loadSpecFromDB(variant)
    if (dbSpec) {
      const cacheEntry = { spec: dbSpec, loadedAt: Date.now() }
      for (const v of variations) {
        specCache.set(v, cacheEntry)
      }
      console.log(`[spec-loader] Loaded spec from DB for: ${moduleName} (found as ${variant})`)
      return dbSpec
    }
  }

  // Fallback: try loading from filesystem
  for (const variant of variations) {
    try {
      const specPath = path.join(SPECS_DIR, `${variant}-complete-spec.json`)
      const content = await fs.readFile(specPath, "utf-8")
      const spec = JSON.parse(content) as ModuleSpec

      // Cache with all variations pointing to the same spec
      const cacheEntry = { spec, loadedAt: Date.now() }
      for (const v of variations) {
        specCache.set(v, cacheEntry)
      }

      console.log(`[spec-loader] Loaded spec for: ${moduleName} (found as ${variant})`)
      return spec
    } catch {
      // Try next variation
      continue
    }
  }

  console.warn(`[spec-loader] No spec found for ${moduleName} (tried DB + filesystem: ${variations.join(", ")}), attempting on-the-fly generation`)

  // Try to generate spec on-the-fly from container metadata
  const generatedSpec = await generateSpecFromContainer(moduleName)
  if (generatedSpec) {
    const cacheEntry = { spec: generatedSpec, loadedAt: Date.now() }
    for (const v of variations) {
      specCache.set(v, cacheEntry)
    }
    console.log(`[spec-loader] Generated spec on-the-fly for: ${moduleName}`)
    return generatedSpec
  }

  console.warn(`[spec-loader] Could not generate spec for ${moduleName}`)
  return null
}

/**
 * Get all possible naming variations for a module.
 * Handles singular/plural and underscore/no-underscore patterns.
 */
function getModuleNameVariations(moduleName: string): string[] {
  const variations = new Set<string>()

  // Original name
  variations.add(moduleName)

  // Handle pluralization
  const pluralized = pluralize(moduleName)
  const singularized = singularize(moduleName)

  variations.add(pluralized)
  variations.add(singularized)

  // Handle underscore variations (e.g., "production_run" vs "productionRun")
  if (moduleName.includes("_")) {
    const camelCase = moduleName.replace(/_([a-z])/g, (_, c) => c.toUpperCase())
    variations.add(camelCase)
    variations.add(pluralize(camelCase))
    variations.add(singularize(camelCase))
  }

  return Array.from(variations)
}

/**
 * Simple pluralization for common patterns.
 */
function pluralize(word: string): string {
  // Already plural patterns
  if (word.endsWith("s") && !word.endsWith("ss")) {
    return word
  }

  // Handle underscore-separated words - pluralize the last word
  if (word.includes("_")) {
    const parts = word.split("_")
    const lastPart = parts[parts.length - 1]
    parts[parts.length - 1] = pluralizeSingleWord(lastPart)
    return parts.join("_")
  }

  return pluralizeSingleWord(word)
}

function pluralizeSingleWord(word: string): string {
  if (word.endsWith("s") && !word.endsWith("ss")) {
    return word // Already plural
  }
  if (word.endsWith("y") && !/[aeiou]y$/i.test(word)) {
    return word.slice(0, -1) + "ies"
  }
  if (word.endsWith("s") || word.endsWith("x") || word.endsWith("ch") || word.endsWith("sh")) {
    return word + "es"
  }
  return word + "s"
}

/**
 * Simple singularization for common patterns.
 */
function singularize(word: string): string {
  // Handle underscore-separated words - singularize the last word
  if (word.includes("_")) {
    const parts = word.split("_")
    const lastPart = parts[parts.length - 1]
    parts[parts.length - 1] = singularizeSingleWord(lastPart)
    return parts.join("_")
  }

  return singularizeSingleWord(word)
}

function singularizeSingleWord(word: string): string {
  if (word.endsWith("ies")) {
    return word.slice(0, -3) + "y"
  }
  if (word.endsWith("es") && (word.endsWith("sses") || word.endsWith("xes") || word.endsWith("ches") || word.endsWith("shes"))) {
    return word.slice(0, -2)
  }
  if (word.endsWith("s") && !word.endsWith("ss")) {
    return word.slice(0, -1)
  }
  return word
}

/**
 * Load all available module specs.
 *
 * @returns Map of module name to spec
 */
export async function loadAllSpecs(): Promise<Map<string, ModuleSpec>> {
  // Check if we recently loaded all specs
  if (
    allSpecsLoadedAt &&
    Date.now() - allSpecsLoadedAt < CACHE_TTL_MS &&
    specCache.size > 0
  ) {
    return new Map(
      Array.from(specCache.entries()).map(([k, v]) => [k, v.spec])
    )
  }

  const specs = new Map<string, ModuleSpec>()

  // Try loading all specs from database first
  const dbSpecs = await loadAllSpecsFromDB()
  if (dbSpecs && dbSpecs.size > 0) {
    for (const [name, spec] of dbSpecs) {
      specs.set(name, spec)
      const cacheEntry = { spec, loadedAt: Date.now() }
      specCache.set(name, cacheEntry)
    }
    allSpecsLoadedAt = Date.now()
    console.log(`[spec-loader] Loaded ${specs.size} module specs from DB`)
    return specs
  }

  // Fallback: load from filesystem
  try {
    const files = await fs.readdir(SPECS_DIR)
    const specFiles = files.filter((f) => f.endsWith("-complete-spec.json"))

    for (const file of specFiles) {
      const moduleName = file.replace("-complete-spec.json", "")
      const spec = await loadModuleSpec(moduleName)
      if (spec) {
        specs.set(moduleName, spec)
      }
    }

    allSpecsLoadedAt = Date.now()
    console.log(`[spec-loader] Loaded ${specs.size} module specs from filesystem`)
  } catch (error) {
    console.warn("[spec-loader] Failed to load specs:", error)
  }

  return specs
}

/**
 * Get all module names that have specs.
 */
export async function getAvailableModules(): Promise<string[]> {
  try {
    const files = await fs.readdir(SPECS_DIR)
    return files
      .filter((f) => f.endsWith("-complete-spec.json"))
      .map((f) => f.replace("-complete-spec.json", ""))
  } catch {
    return []
  }
}

// ─── LLM Context Building ────────────────────────────────────────────────────

/**
 * Build LLM-friendly context from a module spec.
 * This can be used by the query planner to understand entity structure.
 *
 * @param spec - The module spec
 * @returns Formatted context string for LLM
 */
export function buildLLMContextFromSpec(spec: ModuleSpec): string {
  const lines: string[] = []

  lines.push(`### ${spec.module} (Custom Module)`)
  lines.push(`**Entity:** ${spec.dataModel.entityName} (table: ${spec.dataModel.tableName})`)
  lines.push("")

  // Description
  if (spec.dataModel.description) {
    lines.push(`**Description:** ${spec.dataModel.description}`)
    lines.push("")
  }

  // Fields with types
  if (spec.dataModel.fields.length > 0) {
    lines.push(`**Fields:**`)
    for (const field of spec.dataModel.fields) {
      let fieldLine = `- ${field.name}: ${field.type}`
      if (field.primaryKey) fieldLine += " (primary key)"
      else if (field.nullable) fieldLine += " (optional)"
      else fieldLine += " (required)"
      if (field.enumValues && field.enumValues.length > 0) {
        fieldLine += ` [values: ${field.enumValues.join(", ")}]`
      }
      if (field.searchable) fieldLine += " [searchable]"
      if (field.filterable) fieldLine += " [filterable]"
      lines.push(fieldLine)
    }
    lines.push("")
  }

  // Relations with cardinality
  if (spec.dataModel.relations.length > 0) {
    lines.push(`**Relations:**`)
    for (const rel of spec.dataModel.relations) {
      lines.push(`- ${rel.name}: ${rel.cardinality} → ${rel.targetEntity}`)
    }
    lines.push("")
  }

  // Module links (cross-module relationships)
  if (spec.integrationPoints.links.length > 0) {
    lines.push(`**Module Links:**`)
    for (const link of spec.integrationPoints.links) {
      lines.push(`- ${link.sourceEntity} ↔ ${link.targetEntity} (${link.linkType})`)
    }
    lines.push("")
  }

  // Auto-generated service methods
  if (spec.services.autoGeneratedMethods.length > 0) {
    lines.push(`**Service Methods:**`)
    for (const method of spec.services.autoGeneratedMethods) {
      lines.push(`- ${method}`)
    }
    lines.push("")
  }

  // Workflows
  if (spec.workflows.definitions.length > 0) {
    lines.push(`**Workflows (${spec.workflows.count}):**`)
    for (const wf of spec.workflows.definitions.slice(0, 5)) {
      lines.push(`- ${wf.name} (${wf.workflowCategory || "utility"})`)
    }
    if (spec.workflows.count > 5) {
      lines.push(`- ... and ${spec.workflows.count - 5} more`)
    }
    lines.push("")
  }

  // API Endpoints summary
  if (spec.apiSurface.totalEndpoints > 0) {
    lines.push(`**API Endpoints:** ${spec.apiSurface.totalEndpoints} endpoints`)
    // Show a few examples
    const routesByMethod: Record<string, number> = {}
    for (const route of spec.apiSurface.routes) {
      routesByMethod[route.method] = (routesByMethod[route.method] || 0) + 1
    }
    const methodSummary = Object.entries(routesByMethod)
      .map(([m, c]) => `${c} ${m}`)
      .join(", ")
    lines.push(`  (${methodSummary})`)
    lines.push("")
  }

  // CRITICAL: Query Intelligence - Cross-Entity Patterns
  // This tells the LLM HOW to query when dealing with cross-entity queries
  const specAny = spec as any
  if (specAny.queryIntelligence?.crossEntityPatterns?.length > 0) {
    lines.push(`**Query Patterns (IMPORTANT):**`)
    lines.push(`_When querying this module with related entities, use these patterns:_`)
    lines.push("")

    for (const pattern of specAny.queryIntelligence.crossEntityPatterns.slice(0, 5)) {
      lines.push(`**${pattern.description}**`)
      if (pattern.filterField && pattern.filterValue) {
        lines.push(`- Primary entity: \`${pattern.primaryEntity}\``)
        lines.push(`- Filter: \`${pattern.filterField}: "${pattern.filterValue}"\``)
        lines.push(`- Expand: \`${pattern.expandRelation}\``)
      }
      if (pattern.queryCode) {
        lines.push("```typescript")
        lines.push(pattern.queryCode)
        lines.push("```")
      }
      lines.push("")
    }

    if (specAny.queryIntelligence.crossEntityPatterns.length > 5) {
      lines.push(`_... and ${specAny.queryIntelligence.crossEntityPatterns.length - 5} more patterns_`)
      lines.push("")
    }
  }

  // Semantic Status Mappings - user terms to enum values
  if (specAny.queryIntelligence?.semanticMappings?.length > 0) {
    lines.push(`**Status Mappings (user terms → actual values):**`)
    for (const mapping of specAny.queryIntelligence.semanticMappings) {
      lines.push(`Field: \`${mapping.fieldName}\``)
      for (const [enumValue, userTerms] of Object.entries(mapping.userTerms)) {
        if (Array.isArray(userTerms) && userTerms.length > 0) {
          lines.push(`- "${userTerms.slice(0, 3).join('", "')}" → \`${enumValue}\``)
        }
      }
    }
    lines.push("")
  }

  // Inferred Relations from foreign keys
  if (specAny.dataModel?.inferredRelations?.length > 0) {
    lines.push(`**Foreign Key Relations:**`)
    for (const rel of specAny.dataModel.inferredRelations) {
      lines.push(`- \`${rel.fieldName}\` → ${rel.targetEntity} (${rel.targetModule})`)
      if (rel.queryPattern) {
        lines.push(`  _${rel.queryPattern}_`)
      }
    }
    lines.push("")
  }

  return lines.join("\n")
}

/**
 * Build combined LLM context for multiple modules.
 *
 * @param moduleNames - List of module names to include
 * @returns Combined context string
 */
export async function buildCombinedLLMContext(
  moduleNames: string[]
): Promise<string> {
  const contextParts: string[] = [
    "## Module Specifications (from code analysis)",
    "",
    "The following entity specifications were extracted from the codebase.",
    "Use this information to understand entity structure, relations, and valid field values.",
    "",
  ]

  for (const moduleName of moduleNames) {
    const spec = await loadModuleSpec(moduleName)
    if (spec) {
      contextParts.push(buildLLMContextFromSpec(spec))
      contextParts.push("---")
      contextParts.push("")
    }
  }

  return contextParts.join("\n")
}

// ─── Entity Lookup ───────────────────────────────────────────────────────────

/**
 * Get enum values for a specific field.
 *
 * @param moduleName - The module name
 * @param fieldName - The field name
 * @returns Array of enum values or null
 */
export async function getEnumValues(
  moduleName: string,
  fieldName: string
): Promise<string[] | null> {
  const spec = await loadModuleSpec(moduleName)
  if (!spec) return null

  const field = spec.dataModel.fields.find((f) => f.name === fieldName)
  return field?.enumValues || null
}

/**
 * Get valid relations for an entity.
 *
 * @param moduleName - The module name
 * @returns Array of relation names
 */
export async function getValidRelations(
  moduleName: string
): Promise<string[]> {
  const spec = await loadModuleSpec(moduleName)
  if (!spec) return []

  return spec.dataModel.relations.map((r) => r.name)
}

/**
 * Get filterable fields for an entity.
 *
 * @param moduleName - The module name
 * @returns Array of filterable field names
 */
export async function getFilterableFields(
  moduleName: string
): Promise<string[]> {
  const spec = await loadModuleSpec(moduleName)
  if (!spec) return []

  return spec.dataModel.fields
    .filter((f) => f.filterable)
    .map((f) => f.name)
}

/**
 * Get searchable fields for an entity.
 *
 * @param moduleName - The module name
 * @returns Array of searchable field names
 */
export async function getSearchableFields(
  moduleName: string
): Promise<string[]> {
  const spec = await loadModuleSpec(moduleName)
  if (!spec) return []

  return spec.dataModel.fields
    .filter((f) => f.searchable)
    .map((f) => f.name)
}

/**
 * Find modules that link to a given module.
 *
 * @param moduleName - The target module name
 * @returns Array of module names that link to this module
 */
export async function findLinkedModules(
  moduleName: string
): Promise<string[]> {
  const allSpecs = await loadAllSpecs()
  const linkedModules: string[] = []

  for (const [name, spec] of allSpecs) {
    for (const link of spec.integrationPoints.links) {
      if (
        link.targetModule === moduleName ||
        link.sourceModule === moduleName
      ) {
        if (link.targetModule === moduleName) {
          linkedModules.push(link.sourceModule)
        } else {
          linkedModules.push(link.targetModule)
        }
      }
    }
  }

  return [...new Set(linkedModules)]
}

// ─── Cross-Entity Query Support ──────────────────────────────────────────────

/**
 * Find the relationship path between two modules.
 * This helps the query planner understand how to join entities.
 *
 * @param sourceModule - The source module
 * @param targetModule - The target module
 * @returns Relationship info or null
 */
export async function findRelationshipPath(
  sourceModule: string,
  targetModule: string
): Promise<{
  type: "direct" | "via_link" | "via_foreign_key" | "none"
  linkInfo?: LinkSpec
  foreignKeyField?: string
} | null> {
  const sourceSpec = await loadModuleSpec(sourceModule)
  const targetSpec = await loadModuleSpec(targetModule)

  if (!sourceSpec || !targetSpec) return null

  // Check for direct module link
  for (const link of sourceSpec.integrationPoints.links) {
    if (link.targetModule === targetModule) {
      return { type: "via_link", linkInfo: link }
    }
  }

  // Check reverse link (target has link to source)
  for (const link of targetSpec.integrationPoints.links) {
    if (link.targetModule === sourceModule) {
      return { type: "via_link", linkInfo: link }
    }
  }

  // Check for foreign key relationship
  // Look for fields like `design_id` in source that reference target
  const targetEntityName = targetSpec.dataModel.entityName.toLowerCase()
  for (const field of sourceSpec.dataModel.fields) {
    if (
      field.name.endsWith("_id") &&
      field.name.replace("_id", "") === targetEntityName
    ) {
      return { type: "via_foreign_key", foreignKeyField: field.name }
    }
  }

  // Check reverse foreign key
  const sourceEntityName = sourceSpec.dataModel.entityName.toLowerCase()
  for (const field of targetSpec.dataModel.fields) {
    if (
      field.name.endsWith("_id") &&
      field.name.replace("_id", "") === sourceEntityName
    ) {
      return { type: "via_foreign_key", foreignKeyField: field.name }
    }
  }

  return { type: "none" }
}

// ─── Cache Management ────────────────────────────────────────────────────────

/**
 * Clear the spec cache.
 */
export function clearSpecCache(): void {
  specCache.clear()
  allSpecsLoadedAt = null
  console.log("[spec-loader] Cache cleared")
}

/**
 * Get cache statistics.
 */
export function getSpecCacheStats(): {
  cachedModules: number
  cacheAge: number | null
} {
  return {
    cachedModules: specCache.size,
    cacheAge: allSpecsLoadedAt ? Date.now() - allSpecsLoadedAt : null,
  }
}
